// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from
//! `solution/selective_disclosure/selective_disclosure.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq, Clone, Default)]
pub struct AttributeTemplate {
    // message fields
    pub attribute_key: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeTemplate {
    fn default() -> &'a AttributeTemplate {
        <AttributeTemplate as ::protobuf::Message>::default_instance()
    }
}

impl AttributeTemplate {
    pub fn new() -> AttributeTemplate {
        ::std::default::Default::default()
    }

    // repeated string attribute_key = 1;

    pub fn get_attribute_key(&self) -> &[::std::string::String] {
        &self.attribute_key
    }
    pub fn clear_attribute_key(&mut self) {
        self.attribute_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_key(
        &mut self,
        v: ::protobuf::RepeatedField<::std::string::String>,
    )
    {
        self.attribute_key = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_key(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.attribute_key
    }

    // Take field
    pub fn take_attribute_key(
        &mut self,
    ) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.attribute_key,
            ::protobuf::RepeatedField::new(),
        )
    }
}

impl ::protobuf::Message for AttributeTemplate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.attribute_key,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attribute_key {
            my_size += ::protobuf::rt::string_size(1, &value);
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        for v in &self.attribute_key {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeTemplate {
        AttributeTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "attribute_key",
                    |m: &AttributeTemplate| &m.attribute_key,
                    |m: &mut AttributeTemplate| &mut m.attribute_key,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                AttributeTemplate,
            >("AttributeTemplate", fields, file_descriptor_proto())
        })
    }

    fn default_instance() -> &'static AttributeTemplate {
        static instance: ::protobuf::rt::LazyV2<AttributeTemplate> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(AttributeTemplate::new)
    }
}

impl ::protobuf::Clear for AttributeTemplate {
    fn clear(&mut self) {
        self.attribute_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct StringToStringPair {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringToStringPair {
    fn default() -> &'a StringToStringPair {
        <StringToStringPair as ::protobuf::Message>::default_instance()
    }
}

impl StringToStringPair {
    pub fn new() -> StringToStringPair {
        ::std::default::Default::default()
    }

    // string key = 1;

    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;

    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StringToStringPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.key,
                    )?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.value,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringToStringPair {
        StringToStringPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "key",
                    |m: &StringToStringPair| &m.key,
                    |m: &mut StringToStringPair| &mut m.key,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "value",
                    |m: &StringToStringPair| &m.value,
                    |m: &mut StringToStringPair| &mut m.value,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                StringToStringPair,
            >("StringToStringPair", fields, file_descriptor_proto())
        })
    }

    fn default_instance() -> &'static StringToStringPair {
        static instance: ::protobuf::rt::LazyV2<StringToStringPair> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(StringToStringPair::new)
    }
}

impl ::protobuf::Clear for StringToStringPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringToStringPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringToStringPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CredentialTemplate {
    // message fields
    pub credential_schema: ::protobuf::SingularPtrField<AttributeTemplate>,
    pub credential_key_correctness_proof: ::std::string::String,
    pub public_key: ::protobuf::SingularPtrField<TemplatePublicKey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CredentialTemplate {
    fn default() -> &'a CredentialTemplate {
        <CredentialTemplate as ::protobuf::Message>::default_instance()
    }
}

impl CredentialTemplate {
    pub fn new() -> CredentialTemplate {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.selective_disclosure.proto.AttributeTemplate
    // credential_schema = 1;

    pub fn get_credential_schema(&self) -> &AttributeTemplate {
        self.credential_schema.as_ref().unwrap_or_else(|| {
            <AttributeTemplate as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_credential_schema(&mut self) {
        self.credential_schema.clear();
    }

    pub fn has_credential_schema(&self) -> bool {
        self.credential_schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_schema(&mut self, v: AttributeTemplate) {
        self.credential_schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_schema(&mut self) -> &mut AttributeTemplate {
        if self.credential_schema.is_none() {
            self.credential_schema.set_default();
        }
        self.credential_schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_credential_schema(&mut self) -> AttributeTemplate {
        self.credential_schema
            .take()
            .unwrap_or_else(|| AttributeTemplate::new())
    }

    // string credential_key_correctness_proof = 2;

    pub fn get_credential_key_correctness_proof(&self) -> &str {
        &self.credential_key_correctness_proof
    }
    pub fn clear_credential_key_correctness_proof(&mut self) {
        self.credential_key_correctness_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_credential_key_correctness_proof(
        &mut self,
        v: ::std::string::String,
    )
    {
        self.credential_key_correctness_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_key_correctness_proof(
        &mut self,
    ) -> &mut ::std::string::String {
        &mut self.credential_key_correctness_proof
    }

    // Take field
    pub fn take_credential_key_correctness_proof(
        &mut self,
    ) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.credential_key_correctness_proof,
            ::std::string::String::new(),
        )
    }

    // .com.webank.wedpr.selective_disclosure.proto.TemplatePublicKey public_key
    // = 3;

    pub fn get_public_key(&self) -> &TemplatePublicKey {
        self.public_key.as_ref().unwrap_or_else(|| {
            <TemplatePublicKey as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: TemplatePublicKey) {
        self.public_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut TemplatePublicKey {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> TemplatePublicKey {
        self.public_key
            .take()
            .unwrap_or_else(|| TemplatePublicKey::new())
    }
}

impl ::protobuf::Message for CredentialTemplate {
    fn is_initialized(&self) -> bool {
        for v in &self.credential_schema {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.public_key {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.credential_schema,
                    )?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.credential_key_correctness_proof,
                    )?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.public_key,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.credential_schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.credential_key_correctness_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(
                2,
                &self.credential_key_correctness_proof,
            );
        }
        if let Some(ref v) = self.public_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if let Some(ref v) = self.credential_schema.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.credential_key_correctness_proof.is_empty() {
            os.write_string(2, &self.credential_key_correctness_proof)?;
        }
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CredentialTemplate {
        CredentialTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttributeTemplate>>(
                "credential_schema",
                |m: &CredentialTemplate| { &m.credential_schema },
                |m: &mut CredentialTemplate| { &mut m.credential_schema },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credential_key_correctness_proof",
                |m: &CredentialTemplate| { &m.credential_key_correctness_proof },
                |m: &mut CredentialTemplate| { &mut m.credential_key_correctness_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TemplatePublicKey>>(
                "public_key",
                |m: &CredentialTemplate| { &m.public_key },
                |m: &mut CredentialTemplate| { &mut m.public_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CredentialTemplate>(
                "CredentialTemplate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CredentialTemplate {
        static instance: ::protobuf::rt::LazyV2<CredentialTemplate> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(CredentialTemplate::new)
    }
}

impl ::protobuf::Clear for CredentialTemplate {
    fn clear(&mut self) {
        self.credential_schema.clear();
        self.credential_key_correctness_proof.clear();
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CredentialTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CredentialTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TemplatePublicKey {
    // message fields
    pub credential_public_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TemplatePublicKey {
    fn default() -> &'a TemplatePublicKey {
        <TemplatePublicKey as ::protobuf::Message>::default_instance()
    }
}

impl TemplatePublicKey {
    pub fn new() -> TemplatePublicKey {
        ::std::default::Default::default()
    }

    // string credential_public_key = 1;

    pub fn get_credential_public_key(&self) -> &str {
        &self.credential_public_key
    }
    pub fn clear_credential_public_key(&mut self) {
        self.credential_public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_credential_public_key(&mut self, v: ::std::string::String) {
        self.credential_public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_public_key(&mut self) -> &mut ::std::string::String {
        &mut self.credential_public_key
    }

    // Take field
    pub fn take_credential_public_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.credential_public_key,
            ::std::string::String::new(),
        )
    }
}

impl ::protobuf::Message for TemplatePublicKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.credential_public_key,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.credential_public_key.is_empty() {
            my_size +=
                ::protobuf::rt::string_size(1, &self.credential_public_key);
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if !self.credential_public_key.is_empty() {
            os.write_string(1, &self.credential_public_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TemplatePublicKey {
        TemplatePublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "credential_public_key",
                    |m: &TemplatePublicKey| &m.credential_public_key,
                    |m: &mut TemplatePublicKey| &mut m.credential_public_key,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                TemplatePublicKey,
            >("TemplatePublicKey", fields, file_descriptor_proto())
        })
    }

    fn default_instance() -> &'static TemplatePublicKey {
        static instance: ::protobuf::rt::LazyV2<TemplatePublicKey> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(TemplatePublicKey::new)
    }
}

impl ::protobuf::Clear for TemplatePublicKey {
    fn clear(&mut self) {
        self.credential_public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TemplatePublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplatePublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct TemplateSecretKey {
    // message fields
    pub credential_secret_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TemplateSecretKey {
    fn default() -> &'a TemplateSecretKey {
        <TemplateSecretKey as ::protobuf::Message>::default_instance()
    }
}

impl TemplateSecretKey {
    pub fn new() -> TemplateSecretKey {
        ::std::default::Default::default()
    }

    // string credential_secret_key = 1;

    pub fn get_credential_secret_key(&self) -> &str {
        &self.credential_secret_key
    }
    pub fn clear_credential_secret_key(&mut self) {
        self.credential_secret_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_credential_secret_key(&mut self, v: ::std::string::String) {
        self.credential_secret_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_secret_key(&mut self) -> &mut ::std::string::String {
        &mut self.credential_secret_key
    }

    // Take field
    pub fn take_credential_secret_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.credential_secret_key,
            ::std::string::String::new(),
        )
    }
}

impl ::protobuf::Message for TemplateSecretKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.credential_secret_key,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.credential_secret_key.is_empty() {
            my_size +=
                ::protobuf::rt::string_size(1, &self.credential_secret_key);
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if !self.credential_secret_key.is_empty() {
            os.write_string(1, &self.credential_secret_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TemplateSecretKey {
        TemplateSecretKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "credential_secret_key",
                    |m: &TemplateSecretKey| &m.credential_secret_key,
                    |m: &mut TemplateSecretKey| &mut m.credential_secret_key,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                TemplateSecretKey,
            >("TemplateSecretKey", fields, file_descriptor_proto())
        })
    }

    fn default_instance() -> &'static TemplateSecretKey {
        static instance: ::protobuf::rt::LazyV2<TemplateSecretKey> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(TemplateSecretKey::new)
    }
}

impl ::protobuf::Clear for TemplateSecretKey {
    fn clear(&mut self) {
        self.credential_secret_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TemplateSecretKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateSecretKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CredentialInfo {
    // message fields
    pub attribute_pair: ::protobuf::RepeatedField<StringToStringPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CredentialInfo {
    fn default() -> &'a CredentialInfo {
        <CredentialInfo as ::protobuf::Message>::default_instance()
    }
}

impl CredentialInfo {
    pub fn new() -> CredentialInfo {
        ::std::default::Default::default()
    }

    // repeated .com.webank.wedpr.selective_disclosure.proto.StringToStringPair
    // attribute_pair = 1;

    pub fn get_attribute_pair(&self) -> &[StringToStringPair] {
        &self.attribute_pair
    }
    pub fn clear_attribute_pair(&mut self) {
        self.attribute_pair.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_pair(
        &mut self,
        v: ::protobuf::RepeatedField<StringToStringPair>,
    )
    {
        self.attribute_pair = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_pair(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<StringToStringPair> {
        &mut self.attribute_pair
    }

    // Take field
    pub fn take_attribute_pair(
        &mut self,
    ) -> ::protobuf::RepeatedField<StringToStringPair> {
        ::std::mem::replace(
            &mut self.attribute_pair,
            ::protobuf::RepeatedField::new(),
        )
    }
}

impl ::protobuf::Message for CredentialInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute_pair {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.attribute_pair,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attribute_pair {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        for v in &self.attribute_pair {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CredentialInfo {
        CredentialInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringToStringPair>>(
                "attribute_pair",
                |m: &CredentialInfo| { &m.attribute_pair },
                |m: &mut CredentialInfo| { &mut m.attribute_pair },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CredentialInfo>(
                "CredentialInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CredentialInfo {
        static instance: ::protobuf::rt::LazyV2<CredentialInfo> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(CredentialInfo::new)
    }
}

impl ::protobuf::Clear for CredentialInfo {
    fn clear(&mut self) {
        self.attribute_pair.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CredentialInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CredentialInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct BlindedCredentialSecret {
    // message fields
    pub blinded_credential_secrets: ::std::string::String,
    pub blinded_credential_secrets_correctness_proof: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlindedCredentialSecret {
    fn default() -> &'a BlindedCredentialSecret {
        <BlindedCredentialSecret as ::protobuf::Message>::default_instance()
    }
}

impl BlindedCredentialSecret {
    pub fn new() -> BlindedCredentialSecret {
        ::std::default::Default::default()
    }

    // string blinded_credential_secrets = 1;

    pub fn get_blinded_credential_secrets(&self) -> &str {
        &self.blinded_credential_secrets
    }
    pub fn clear_blinded_credential_secrets(&mut self) {
        self.blinded_credential_secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinded_credential_secrets(&mut self, v: ::std::string::String) {
        self.blinded_credential_secrets = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinded_credential_secrets(
        &mut self,
    ) -> &mut ::std::string::String {
        &mut self.blinded_credential_secrets
    }

    // Take field
    pub fn take_blinded_credential_secrets(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.blinded_credential_secrets,
            ::std::string::String::new(),
        )
    }

    // string blinded_credential_secrets_correctness_proof = 2;

    pub fn get_blinded_credential_secrets_correctness_proof(&self) -> &str {
        &self.blinded_credential_secrets_correctness_proof
    }
    pub fn clear_blinded_credential_secrets_correctness_proof(&mut self) {
        self.blinded_credential_secrets_correctness_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinded_credential_secrets_correctness_proof(
        &mut self,
        v: ::std::string::String,
    )
    {
        self.blinded_credential_secrets_correctness_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinded_credential_secrets_correctness_proof(
        &mut self,
    ) -> &mut ::std::string::String {
        &mut self.blinded_credential_secrets_correctness_proof
    }

    // Take field
    pub fn take_blinded_credential_secrets_correctness_proof(
        &mut self,
    ) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.blinded_credential_secrets_correctness_proof,
            ::std::string::String::new(),
        )
    }
}

impl ::protobuf::Message for BlindedCredentialSecret {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.blinded_credential_secrets,
                    )?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.blinded_credential_secrets_correctness_proof,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blinded_credential_secrets.is_empty() {
            my_size += ::protobuf::rt::string_size(
                1,
                &self.blinded_credential_secrets,
            );
        }
        if !self.blinded_credential_secrets_correctness_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(
                2,
                &self.blinded_credential_secrets_correctness_proof,
            );
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if !self.blinded_credential_secrets.is_empty() {
            os.write_string(1, &self.blinded_credential_secrets)?;
        }
        if !self.blinded_credential_secrets_correctness_proof.is_empty() {
            os.write_string(
                2,
                &self.blinded_credential_secrets_correctness_proof,
            )?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlindedCredentialSecret {
        BlindedCredentialSecret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "blinded_credential_secrets",
                    |m: &BlindedCredentialSecret| &m.blinded_credential_secrets,
                    |m: &mut BlindedCredentialSecret| {
                        &mut m.blinded_credential_secrets
                    },
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "blinded_credential_secrets_correctness_proof",
                    |m: &BlindedCredentialSecret| {
                        &m.blinded_credential_secrets_correctness_proof
                    },
                    |m: &mut BlindedCredentialSecret| {
                        &mut m.blinded_credential_secrets_correctness_proof
                    },
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                BlindedCredentialSecret,
            >(
                "BlindedCredentialSecret", fields, file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlindedCredentialSecret {
        static instance: ::protobuf::rt::LazyV2<BlindedCredentialSecret> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(BlindedCredentialSecret::new)
    }
}

impl ::protobuf::Clear for BlindedCredentialSecret {
    fn clear(&mut self) {
        self.blinded_credential_secrets.clear();
        self.blinded_credential_secrets_correctness_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlindedCredentialSecret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlindedCredentialSecret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CredentialSignature {
    // message fields
    pub credential_signature: ::std::string::String,
    pub signature_correctness_proof: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CredentialSignature {
    fn default() -> &'a CredentialSignature {
        <CredentialSignature as ::protobuf::Message>::default_instance()
    }
}

impl CredentialSignature {
    pub fn new() -> CredentialSignature {
        ::std::default::Default::default()
    }

    // string credential_signature = 1;

    pub fn get_credential_signature(&self) -> &str {
        &self.credential_signature
    }
    pub fn clear_credential_signature(&mut self) {
        self.credential_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_credential_signature(&mut self, v: ::std::string::String) {
        self.credential_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_signature(&mut self) -> &mut ::std::string::String {
        &mut self.credential_signature
    }

    // Take field
    pub fn take_credential_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.credential_signature,
            ::std::string::String::new(),
        )
    }

    // string signature_correctness_proof = 2;

    pub fn get_signature_correctness_proof(&self) -> &str {
        &self.signature_correctness_proof
    }
    pub fn clear_signature_correctness_proof(&mut self) {
        self.signature_correctness_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature_correctness_proof(
        &mut self,
        v: ::std::string::String,
    )
    {
        self.signature_correctness_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature_correctness_proof(
        &mut self,
    ) -> &mut ::std::string::String {
        &mut self.signature_correctness_proof
    }

    // Take field
    pub fn take_signature_correctness_proof(
        &mut self,
    ) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.signature_correctness_proof,
            ::std::string::String::new(),
        )
    }
}

impl ::protobuf::Message for CredentialSignature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.credential_signature,
                    )?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.signature_correctness_proof,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.credential_signature.is_empty() {
            my_size +=
                ::protobuf::rt::string_size(1, &self.credential_signature);
        }
        if !self.signature_correctness_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(
                2,
                &self.signature_correctness_proof,
            );
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if !self.credential_signature.is_empty() {
            os.write_string(1, &self.credential_signature)?;
        }
        if !self.signature_correctness_proof.is_empty() {
            os.write_string(2, &self.signature_correctness_proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CredentialSignature {
        CredentialSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "credential_signature",
                    |m: &CredentialSignature| &m.credential_signature,
                    |m: &mut CredentialSignature| &mut m.credential_signature,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "signature_correctness_proof",
                    |m: &CredentialSignature| &m.signature_correctness_proof,
                    |m: &mut CredentialSignature| {
                        &mut m.signature_correctness_proof
                    },
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                CredentialSignature,
            >("CredentialSignature", fields, file_descriptor_proto())
        })
    }

    fn default_instance() -> &'static CredentialSignature {
        static instance: ::protobuf::rt::LazyV2<CredentialSignature> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(CredentialSignature::new)
    }
}

impl ::protobuf::Clear for CredentialSignature {
    fn clear(&mut self) {
        self.credential_signature.clear();
        self.signature_correctness_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CredentialSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CredentialSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct Predicate {
    // message fields
    pub attribute_name: ::std::string::String,
    pub predicate_type: ::std::string::String,
    pub value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Predicate {
    fn default() -> &'a Predicate {
        <Predicate as ::protobuf::Message>::default_instance()
    }
}

impl Predicate {
    pub fn new() -> Predicate {
        ::std::default::Default::default()
    }

    // string attribute_name = 1;

    pub fn get_attribute_name(&self) -> &str {
        &self.attribute_name
    }
    pub fn clear_attribute_name(&mut self) {
        self.attribute_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_name(&mut self, v: ::std::string::String) {
        self.attribute_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute_name(&mut self) -> &mut ::std::string::String {
        &mut self.attribute_name
    }

    // Take field
    pub fn take_attribute_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.attribute_name,
            ::std::string::String::new(),
        )
    }

    // string predicate_type = 2;

    pub fn get_predicate_type(&self) -> &str {
        &self.predicate_type
    }
    pub fn clear_predicate_type(&mut self) {
        self.predicate_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_predicate_type(&mut self, v: ::std::string::String) {
        self.predicate_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predicate_type(&mut self) -> &mut ::std::string::String {
        &mut self.predicate_type
    }

    // Take field
    pub fn take_predicate_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.predicate_type,
            ::std::string::String::new(),
        )
    }

    // uint64 value = 3;

    pub fn get_value(&self) -> u64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }
}

impl ::protobuf::Message for Predicate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.attribute_name,
                    )?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.predicate_type,
                    )?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(
                            ::protobuf::rt::unexpected_wire_type(wire_type),
                        );
                    }
                    let tmp = is.read_uint64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.attribute_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.attribute_name);
        }
        if !self.predicate_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.predicate_type);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.value,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if !self.attribute_name.is_empty() {
            os.write_string(1, &self.attribute_name)?;
        }
        if !self.predicate_type.is_empty() {
            os.write_string(2, &self.predicate_type)?;
        }
        if self.value != 0 {
            os.write_uint64(3, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Predicate {
        Predicate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "attribute_name",
                    |m: &Predicate| &m.attribute_name,
                    |m: &mut Predicate| &mut m.attribute_name,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "predicate_type",
                    |m: &Predicate| &m.predicate_type,
                    |m: &mut Predicate| &mut m.predicate_type,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeUint64,
                >(
                    "value",
                    |m: &Predicate| &m.value,
                    |m: &mut Predicate| &mut m.value,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Predicate>(
                "Predicate",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static Predicate {
        static instance: ::protobuf::rt::LazyV2<Predicate> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(Predicate::new)
    }
}

impl ::protobuf::Clear for Predicate {
    fn clear(&mut self) {
        self.attribute_name.clear();
        self.predicate_type.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Predicate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Predicate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct VerificationRule {
    // message fields
    pub revealed_attribute: ::protobuf::RepeatedField<::std::string::String>,
    pub predicate_attribute: ::protobuf::RepeatedField<Predicate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerificationRule {
    fn default() -> &'a VerificationRule {
        <VerificationRule as ::protobuf::Message>::default_instance()
    }
}

impl VerificationRule {
    pub fn new() -> VerificationRule {
        ::std::default::Default::default()
    }

    // repeated string revealed_attribute = 1;

    pub fn get_revealed_attribute(&self) -> &[::std::string::String] {
        &self.revealed_attribute
    }
    pub fn clear_revealed_attribute(&mut self) {
        self.revealed_attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_revealed_attribute(
        &mut self,
        v: ::protobuf::RepeatedField<::std::string::String>,
    )
    {
        self.revealed_attribute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_revealed_attribute(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.revealed_attribute
    }

    // Take field
    pub fn take_revealed_attribute(
        &mut self,
    ) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(
            &mut self.revealed_attribute,
            ::protobuf::RepeatedField::new(),
        )
    }

    // repeated .com.webank.wedpr.selective_disclosure.proto.Predicate
    // predicate_attribute = 2;

    pub fn get_predicate_attribute(&self) -> &[Predicate] {
        &self.predicate_attribute
    }
    pub fn clear_predicate_attribute(&mut self) {
        self.predicate_attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_predicate_attribute(
        &mut self,
        v: ::protobuf::RepeatedField<Predicate>,
    )
    {
        self.predicate_attribute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_predicate_attribute(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<Predicate> {
        &mut self.predicate_attribute
    }

    // Take field
    pub fn take_predicate_attribute(
        &mut self,
    ) -> ::protobuf::RepeatedField<Predicate> {
        ::std::mem::replace(
            &mut self.predicate_attribute,
            ::protobuf::RepeatedField::new(),
        )
    }
}

impl ::protobuf::Message for VerificationRule {
    fn is_initialized(&self) -> bool {
        for v in &self.predicate_attribute {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.revealed_attribute,
                    )?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.predicate_attribute,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.revealed_attribute {
            my_size += ::protobuf::rt::string_size(1, &value);
        }
        for value in &self.predicate_attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        for v in &self.revealed_attribute {
            os.write_string(1, &v)?;
        }
        for v in &self.predicate_attribute {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerificationRule {
        VerificationRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "revealed_attribute",
                    |m: &VerificationRule| &m.revealed_attribute,
                    |m: &mut VerificationRule| &mut m.revealed_attribute,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<Predicate>,
                >(
                    "predicate_attribute",
                    |m: &VerificationRule| &m.predicate_attribute,
                    |m: &mut VerificationRule| &mut m.predicate_attribute,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                VerificationRule,
            >("VerificationRule", fields, file_descriptor_proto())
        })
    }

    fn default_instance() -> &'static VerificationRule {
        static instance: ::protobuf::rt::LazyV2<VerificationRule> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(VerificationRule::new)
    }
}

impl ::protobuf::Clear for VerificationRule {
    fn clear(&mut self) {
        self.revealed_attribute.clear();
        self.predicate_attribute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerificationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RevealedAttributeInfo {
    // message fields
    pub attr: ::protobuf::RepeatedField<StringToStringPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RevealedAttributeInfo {
    fn default() -> &'a RevealedAttributeInfo {
        <RevealedAttributeInfo as ::protobuf::Message>::default_instance()
    }
}

impl RevealedAttributeInfo {
    pub fn new() -> RevealedAttributeInfo {
        ::std::default::Default::default()
    }

    // repeated .com.webank.wedpr.selective_disclosure.proto.StringToStringPair
    // attr = 1;

    pub fn get_attr(&self) -> &[StringToStringPair] {
        &self.attr
    }
    pub fn clear_attr(&mut self) {
        self.attr.clear();
    }

    // Param is passed by value, moved
    pub fn set_attr(
        &mut self,
        v: ::protobuf::RepeatedField<StringToStringPair>,
    )
    {
        self.attr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attr(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<StringToStringPair> {
        &mut self.attr
    }

    // Take field
    pub fn take_attr(
        &mut self,
    ) -> ::protobuf::RepeatedField<StringToStringPair> {
        ::std::mem::replace(&mut self.attr, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RevealedAttributeInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.attr {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.attr,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attr {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        for v in &self.attr {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RevealedAttributeInfo {
        RevealedAttributeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<StringToStringPair>,
                >(
                    "attr",
                    |m: &RevealedAttributeInfo| &m.attr,
                    |m: &mut RevealedAttributeInfo| &mut m.attr,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                RevealedAttributeInfo,
            >(
                "RevealedAttributeInfo", fields, file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RevealedAttributeInfo {
        static instance: ::protobuf::rt::LazyV2<RevealedAttributeInfo> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(RevealedAttributeInfo::new)
    }
}

impl ::protobuf::Clear for RevealedAttributeInfo {
    fn clear(&mut self) {
        self.attr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RevealedAttributeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RevealedAttributeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct CredentialSignatureRequest {
    // message fields
    pub credential_info: ::protobuf::SingularPtrField<CredentialInfo>,
    pub blinded_credential_secrets: ::std::string::String,
    pub blinded_credential_secrets_correctness_proof: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CredentialSignatureRequest {
    fn default() -> &'a CredentialSignatureRequest {
        <CredentialSignatureRequest as ::protobuf::Message>::default_instance()
    }
}

impl CredentialSignatureRequest {
    pub fn new() -> CredentialSignatureRequest {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.selective_disclosure.proto.CredentialInfo
    // credential_info = 1;

    pub fn get_credential_info(&self) -> &CredentialInfo {
        self.credential_info.as_ref().unwrap_or_else(|| {
            <CredentialInfo as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_credential_info(&mut self) {
        self.credential_info.clear();
    }

    pub fn has_credential_info(&self) -> bool {
        self.credential_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_info(&mut self, v: CredentialInfo) {
        self.credential_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_info(&mut self) -> &mut CredentialInfo {
        if self.credential_info.is_none() {
            self.credential_info.set_default();
        }
        self.credential_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_credential_info(&mut self) -> CredentialInfo {
        self.credential_info
            .take()
            .unwrap_or_else(|| CredentialInfo::new())
    }

    // string blinded_credential_secrets = 2;

    pub fn get_blinded_credential_secrets(&self) -> &str {
        &self.blinded_credential_secrets
    }
    pub fn clear_blinded_credential_secrets(&mut self) {
        self.blinded_credential_secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinded_credential_secrets(&mut self, v: ::std::string::String) {
        self.blinded_credential_secrets = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinded_credential_secrets(
        &mut self,
    ) -> &mut ::std::string::String {
        &mut self.blinded_credential_secrets
    }

    // Take field
    pub fn take_blinded_credential_secrets(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.blinded_credential_secrets,
            ::std::string::String::new(),
        )
    }

    // string blinded_credential_secrets_correctness_proof = 3;

    pub fn get_blinded_credential_secrets_correctness_proof(&self) -> &str {
        &self.blinded_credential_secrets_correctness_proof
    }
    pub fn clear_blinded_credential_secrets_correctness_proof(&mut self) {
        self.blinded_credential_secrets_correctness_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinded_credential_secrets_correctness_proof(
        &mut self,
        v: ::std::string::String,
    )
    {
        self.blinded_credential_secrets_correctness_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinded_credential_secrets_correctness_proof(
        &mut self,
    ) -> &mut ::std::string::String {
        &mut self.blinded_credential_secrets_correctness_proof
    }

    // Take field
    pub fn take_blinded_credential_secrets_correctness_proof(
        &mut self,
    ) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.blinded_credential_secrets_correctness_proof,
            ::std::string::String::new(),
        )
    }
}

impl ::protobuf::Message for CredentialSignatureRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.credential_info {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.credential_info,
                    )?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.blinded_credential_secrets,
                    )?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.blinded_credential_secrets_correctness_proof,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.credential_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.blinded_credential_secrets.is_empty() {
            my_size += ::protobuf::rt::string_size(
                2,
                &self.blinded_credential_secrets,
            );
        }
        if !self.blinded_credential_secrets_correctness_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(
                3,
                &self.blinded_credential_secrets_correctness_proof,
            );
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if let Some(ref v) = self.credential_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.blinded_credential_secrets.is_empty() {
            os.write_string(2, &self.blinded_credential_secrets)?;
        }
        if !self.blinded_credential_secrets_correctness_proof.is_empty() {
            os.write_string(
                3,
                &self.blinded_credential_secrets_correctness_proof,
            )?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CredentialSignatureRequest {
        CredentialSignatureRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CredentialInfo>>(
                "credential_info",
                |m: &CredentialSignatureRequest| { &m.credential_info },
                |m: &mut CredentialSignatureRequest| { &mut m.credential_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blinded_credential_secrets",
                |m: &CredentialSignatureRequest| { &m.blinded_credential_secrets },
                |m: &mut CredentialSignatureRequest| { &mut m.blinded_credential_secrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blinded_credential_secrets_correctness_proof",
                |m: &CredentialSignatureRequest| { &m.blinded_credential_secrets_correctness_proof },
                |m: &mut CredentialSignatureRequest| { &mut m.blinded_credential_secrets_correctness_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CredentialSignatureRequest>(
                "CredentialSignatureRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CredentialSignatureRequest {
        static instance: ::protobuf::rt::LazyV2<CredentialSignatureRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(CredentialSignatureRequest::new)
    }
}

impl ::protobuf::Clear for CredentialSignatureRequest {
    fn clear(&mut self) {
        self.credential_info.clear();
        self.blinded_credential_secrets.clear();
        self.blinded_credential_secrets_correctness_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CredentialSignatureRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CredentialSignatureRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct VerificationRequest {
    // message fields
    pub credential_template: ::protobuf::SingularPtrField<CredentialTemplate>,
    pub verification_proof: ::std::string::String,
    pub verification_nonce: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerificationRequest {
    fn default() -> &'a VerificationRequest {
        <VerificationRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerificationRequest {
    pub fn new() -> VerificationRequest {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.selective_disclosure.proto.CredentialTemplate
    // credential_template = 1;

    pub fn get_credential_template(&self) -> &CredentialTemplate {
        self.credential_template.as_ref().unwrap_or_else(|| {
            <CredentialTemplate as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_credential_template(&mut self) {
        self.credential_template.clear();
    }

    pub fn has_credential_template(&self) -> bool {
        self.credential_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_template(&mut self, v: CredentialTemplate) {
        self.credential_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_template(&mut self) -> &mut CredentialTemplate {
        if self.credential_template.is_none() {
            self.credential_template.set_default();
        }
        self.credential_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_credential_template(&mut self) -> CredentialTemplate {
        self.credential_template
            .take()
            .unwrap_or_else(|| CredentialTemplate::new())
    }

    // string verification_proof = 2;

    pub fn get_verification_proof(&self) -> &str {
        &self.verification_proof
    }
    pub fn clear_verification_proof(&mut self) {
        self.verification_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_verification_proof(&mut self, v: ::std::string::String) {
        self.verification_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verification_proof(&mut self) -> &mut ::std::string::String {
        &mut self.verification_proof
    }

    // Take field
    pub fn take_verification_proof(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.verification_proof,
            ::std::string::String::new(),
        )
    }

    // string verification_nonce = 3;

    pub fn get_verification_nonce(&self) -> &str {
        &self.verification_nonce
    }
    pub fn clear_verification_nonce(&mut self) {
        self.verification_nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_verification_nonce(&mut self, v: ::std::string::String) {
        self.verification_nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verification_nonce(&mut self) -> &mut ::std::string::String {
        &mut self.verification_nonce
    }

    // Take field
    pub fn take_verification_nonce(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.verification_nonce,
            ::std::string::String::new(),
        )
    }
}

impl ::protobuf::Message for VerificationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.credential_template {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.credential_template,
                    )?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.verification_proof,
                    )?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.verification_nonce,
                    )?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.credential_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.verification_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.verification_proof);
        }
        if !self.verification_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.verification_nonce);
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if let Some(ref v) = self.credential_template.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.verification_proof.is_empty() {
            os.write_string(2, &self.verification_proof)?;
        }
        if !self.verification_nonce.is_empty() {
            os.write_string(3, &self.verification_nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerificationRequest {
        VerificationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CredentialTemplate>>(
                "credential_template",
                |m: &VerificationRequest| { &m.credential_template },
                |m: &mut VerificationRequest| { &mut m.credential_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "verification_proof",
                |m: &VerificationRequest| { &m.verification_proof },
                |m: &mut VerificationRequest| { &mut m.verification_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "verification_nonce",
                |m: &VerificationRequest| { &m.verification_nonce },
                |m: &mut VerificationRequest| { &mut m.verification_nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerificationRequest>(
                "VerificationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerificationRequest {
        static instance: ::protobuf::rt::LazyV2<VerificationRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(VerificationRequest::new)
    }
}

impl ::protobuf::Clear for VerificationRequest {
    fn clear(&mut self) {
        self.credential_template.clear();
        self.verification_proof.clear();
        self.verification_nonce.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerificationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct SelectiveDisclosureResult {
    // message fields
    pub credential_template: ::protobuf::SingularPtrField<CredentialTemplate>,
    pub template_secret_key: ::protobuf::SingularPtrField<TemplateSecretKey>,
    pub credential_signature: ::protobuf::SingularPtrField<CredentialSignature>,
    pub nonce: ::std::string::String,
    pub credential_signature_request:
        ::protobuf::SingularPtrField<CredentialSignatureRequest>,
    pub master_secret: ::std::string::String,
    pub credential_secrets_blinding_factors: ::std::string::String,
    pub nonce_credential: ::std::string::String,
    pub verification_request: ::protobuf::SingularPtrField<VerificationRequest>,
    pub revealed_attribute_info:
        ::protobuf::SingularPtrField<RevealedAttributeInfo>,
    pub result: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelectiveDisclosureResult {
    fn default() -> &'a SelectiveDisclosureResult {
        <SelectiveDisclosureResult as ::protobuf::Message>::default_instance()
    }
}

impl SelectiveDisclosureResult {
    pub fn new() -> SelectiveDisclosureResult {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.selective_disclosure.proto.CredentialTemplate
    // credential_template = 1;

    pub fn get_credential_template(&self) -> &CredentialTemplate {
        self.credential_template.as_ref().unwrap_or_else(|| {
            <CredentialTemplate as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_credential_template(&mut self) {
        self.credential_template.clear();
    }

    pub fn has_credential_template(&self) -> bool {
        self.credential_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_template(&mut self, v: CredentialTemplate) {
        self.credential_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_template(&mut self) -> &mut CredentialTemplate {
        if self.credential_template.is_none() {
            self.credential_template.set_default();
        }
        self.credential_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_credential_template(&mut self) -> CredentialTemplate {
        self.credential_template
            .take()
            .unwrap_or_else(|| CredentialTemplate::new())
    }

    // .com.webank.wedpr.selective_disclosure.proto.TemplateSecretKey
    // template_secret_key = 2;

    pub fn get_template_secret_key(&self) -> &TemplateSecretKey {
        self.template_secret_key.as_ref().unwrap_or_else(|| {
            <TemplateSecretKey as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_template_secret_key(&mut self) {
        self.template_secret_key.clear();
    }

    pub fn has_template_secret_key(&self) -> bool {
        self.template_secret_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_secret_key(&mut self, v: TemplateSecretKey) {
        self.template_secret_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_secret_key(&mut self) -> &mut TemplateSecretKey {
        if self.template_secret_key.is_none() {
            self.template_secret_key.set_default();
        }
        self.template_secret_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_secret_key(&mut self) -> TemplateSecretKey {
        self.template_secret_key
            .take()
            .unwrap_or_else(|| TemplateSecretKey::new())
    }

    // .com.webank.wedpr.selective_disclosure.proto.CredentialSignature
    // credential_signature = 3;

    pub fn get_credential_signature(&self) -> &CredentialSignature {
        self.credential_signature.as_ref().unwrap_or_else(|| {
            <CredentialSignature as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_credential_signature(&mut self) {
        self.credential_signature.clear();
    }

    pub fn has_credential_signature(&self) -> bool {
        self.credential_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_signature(&mut self, v: CredentialSignature) {
        self.credential_signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_signature(&mut self) -> &mut CredentialSignature {
        if self.credential_signature.is_none() {
            self.credential_signature.set_default();
        }
        self.credential_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_credential_signature(&mut self) -> CredentialSignature {
        self.credential_signature
            .take()
            .unwrap_or_else(|| CredentialSignature::new())
    }

    // string nonce = 4;

    pub fn get_nonce(&self) -> &str {
        &self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::string::String) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::string::String {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nonce, ::std::string::String::new())
    }

    // .com.webank.wedpr.selective_disclosure.proto.CredentialSignatureRequest
    // credential_signature_request = 5;

    pub fn get_credential_signature_request(
        &self,
    ) -> &CredentialSignatureRequest {
        self.credential_signature_request.as_ref().unwrap_or_else(|| <CredentialSignatureRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_credential_signature_request(&mut self) {
        self.credential_signature_request.clear();
    }

    pub fn has_credential_signature_request(&self) -> bool {
        self.credential_signature_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_signature_request(
        &mut self,
        v: CredentialSignatureRequest,
    )
    {
        self.credential_signature_request =
            ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_signature_request(
        &mut self,
    ) -> &mut CredentialSignatureRequest {
        if self.credential_signature_request.is_none() {
            self.credential_signature_request.set_default();
        }
        self.credential_signature_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_credential_signature_request(
        &mut self,
    ) -> CredentialSignatureRequest {
        self.credential_signature_request
            .take()
            .unwrap_or_else(|| CredentialSignatureRequest::new())
    }

    // string master_secret = 6;

    pub fn get_master_secret(&self) -> &str {
        &self.master_secret
    }
    pub fn clear_master_secret(&mut self) {
        self.master_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_master_secret(&mut self, v: ::std::string::String) {
        self.master_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_master_secret(&mut self) -> &mut ::std::string::String {
        &mut self.master_secret
    }

    // Take field
    pub fn take_master_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.master_secret,
            ::std::string::String::new(),
        )
    }

    // string credential_secrets_blinding_factors = 7;

    pub fn get_credential_secrets_blinding_factors(&self) -> &str {
        &self.credential_secrets_blinding_factors
    }
    pub fn clear_credential_secrets_blinding_factors(&mut self) {
        self.credential_secrets_blinding_factors.clear();
    }

    // Param is passed by value, moved
    pub fn set_credential_secrets_blinding_factors(
        &mut self,
        v: ::std::string::String,
    )
    {
        self.credential_secrets_blinding_factors = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_secrets_blinding_factors(
        &mut self,
    ) -> &mut ::std::string::String {
        &mut self.credential_secrets_blinding_factors
    }

    // Take field
    pub fn take_credential_secrets_blinding_factors(
        &mut self,
    ) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.credential_secrets_blinding_factors,
            ::std::string::String::new(),
        )
    }

    // string nonce_credential = 8;

    pub fn get_nonce_credential(&self) -> &str {
        &self.nonce_credential
    }
    pub fn clear_nonce_credential(&mut self) {
        self.nonce_credential.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce_credential(&mut self, v: ::std::string::String) {
        self.nonce_credential = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce_credential(&mut self) -> &mut ::std::string::String {
        &mut self.nonce_credential
    }

    // Take field
    pub fn take_nonce_credential(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.nonce_credential,
            ::std::string::String::new(),
        )
    }

    // .com.webank.wedpr.selective_disclosure.proto.VerificationRequest
    // verification_request = 9;

    pub fn get_verification_request(&self) -> &VerificationRequest {
        self.verification_request.as_ref().unwrap_or_else(|| {
            <VerificationRequest as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_verification_request(&mut self) {
        self.verification_request.clear();
    }

    pub fn has_verification_request(&self) -> bool {
        self.verification_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verification_request(&mut self, v: VerificationRequest) {
        self.verification_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verification_request(&mut self) -> &mut VerificationRequest {
        if self.verification_request.is_none() {
            self.verification_request.set_default();
        }
        self.verification_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_verification_request(&mut self) -> VerificationRequest {
        self.verification_request
            .take()
            .unwrap_or_else(|| VerificationRequest::new())
    }

    // .com.webank.wedpr.selective_disclosure.proto.RevealedAttributeInfo
    // revealed_attribute_info = 10;

    pub fn get_revealed_attribute_info(&self) -> &RevealedAttributeInfo {
        self.revealed_attribute_info.as_ref().unwrap_or_else(|| {
            <RevealedAttributeInfo as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_revealed_attribute_info(&mut self) {
        self.revealed_attribute_info.clear();
    }

    pub fn has_revealed_attribute_info(&self) -> bool {
        self.revealed_attribute_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revealed_attribute_info(&mut self, v: RevealedAttributeInfo) {
        self.revealed_attribute_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revealed_attribute_info(
        &mut self,
    ) -> &mut RevealedAttributeInfo {
        if self.revealed_attribute_info.is_none() {
            self.revealed_attribute_info.set_default();
        }
        self.revealed_attribute_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_revealed_attribute_info(&mut self) -> RevealedAttributeInfo {
        self.revealed_attribute_info
            .take()
            .unwrap_or_else(|| RevealedAttributeInfo::new())
    }

    // bool result = 11;

    pub fn get_result(&self) -> bool {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = false;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = v;
    }
}

impl ::protobuf::Message for SelectiveDisclosureResult {
    fn is_initialized(&self) -> bool {
        for v in &self.credential_template {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.template_secret_key {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.credential_signature {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.credential_signature_request {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.verification_request {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.revealed_attribute_info {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.credential_template,
                    )?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.template_secret_key,
                    )?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.credential_signature,
                    )?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.nonce,
                    )?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.credential_signature_request,
                    )?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.master_secret,
                    )?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.credential_secrets_blinding_factors,
                    )?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.nonce_credential,
                    )?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.verification_request,
                    )?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.revealed_attribute_info,
                    )?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(
                            ::protobuf::rt::unexpected_wire_type(wire_type),
                        );
                    }
                    let tmp = is.read_bool()?;
                    self.result = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.credential_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.template_secret_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.credential_signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.nonce);
        }
        if let Some(ref v) = self.credential_signature_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.master_secret.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.master_secret);
        }
        if !self.credential_secrets_blinding_factors.is_empty() {
            my_size += ::protobuf::rt::string_size(
                7,
                &self.credential_secrets_blinding_factors,
            );
        }
        if !self.nonce_credential.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.nonce_credential);
        }
        if let Some(ref v) = self.verification_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.revealed_attribute_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.result != false {
            my_size += 2;
        }
        my_size +=
            ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()>
    {
        if let Some(ref v) = self.credential_template.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.template_secret_key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.credential_signature.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.nonce.is_empty() {
            os.write_string(4, &self.nonce)?;
        }
        if let Some(ref v) = self.credential_signature_request.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.master_secret.is_empty() {
            os.write_string(6, &self.master_secret)?;
        }
        if !self.credential_secrets_blinding_factors.is_empty() {
            os.write_string(7, &self.credential_secrets_blinding_factors)?;
        }
        if !self.nonce_credential.is_empty() {
            os.write_string(8, &self.nonce_credential)?;
        }
        if let Some(ref v) = self.verification_request.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.revealed_attribute_info.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.result != false {
            os.write_bool(11, self.result)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(
        self: ::std::boxed::Box<Self>,
    ) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelectiveDisclosureResult {
        SelectiveDisclosureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<
            ::protobuf::reflect::MessageDescriptor,
        > = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CredentialTemplate>>(
                "credential_template",
                |m: &SelectiveDisclosureResult| { &m.credential_template },
                |m: &mut SelectiveDisclosureResult| { &mut m.credential_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TemplateSecretKey>>(
                "template_secret_key",
                |m: &SelectiveDisclosureResult| { &m.template_secret_key },
                |m: &mut SelectiveDisclosureResult| { &mut m.template_secret_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CredentialSignature>>(
                "credential_signature",
                |m: &SelectiveDisclosureResult| { &m.credential_signature },
                |m: &mut SelectiveDisclosureResult| { &mut m.credential_signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nonce",
                |m: &SelectiveDisclosureResult| { &m.nonce },
                |m: &mut SelectiveDisclosureResult| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CredentialSignatureRequest>>(
                "credential_signature_request",
                |m: &SelectiveDisclosureResult| { &m.credential_signature_request },
                |m: &mut SelectiveDisclosureResult| { &mut m.credential_signature_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "master_secret",
                |m: &SelectiveDisclosureResult| { &m.master_secret },
                |m: &mut SelectiveDisclosureResult| { &mut m.master_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credential_secrets_blinding_factors",
                |m: &SelectiveDisclosureResult| { &m.credential_secrets_blinding_factors },
                |m: &mut SelectiveDisclosureResult| { &mut m.credential_secrets_blinding_factors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nonce_credential",
                |m: &SelectiveDisclosureResult| { &m.nonce_credential },
                |m: &mut SelectiveDisclosureResult| { &mut m.nonce_credential },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VerificationRequest>>(
                "verification_request",
                |m: &SelectiveDisclosureResult| { &m.verification_request },
                |m: &mut SelectiveDisclosureResult| { &mut m.verification_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RevealedAttributeInfo>>(
                "revealed_attribute_info",
                |m: &SelectiveDisclosureResult| { &m.revealed_attribute_info },
                |m: &mut SelectiveDisclosureResult| { &mut m.revealed_attribute_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &SelectiveDisclosureResult| { &m.result },
                |m: &mut SelectiveDisclosureResult| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelectiveDisclosureResult>(
                "SelectiveDisclosureResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelectiveDisclosureResult {
        static instance: ::protobuf::rt::LazyV2<SelectiveDisclosureResult> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(SelectiveDisclosureResult::new)
    }
}

impl ::protobuf::Clear for SelectiveDisclosureResult {
    fn clear(&mut self) {
        self.credential_template.clear();
        self.template_secret_key.clear();
        self.credential_signature.clear();
        self.nonce.clear();
        self.credential_signature_request.clear();
        self.master_secret.clear();
        self.credential_secrets_blinding_factors.clear();
        self.nonce_credential.clear();
        self.verification_request.clear();
        self.revealed_attribute_info.clear();
        self.result = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelectiveDisclosureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectiveDisclosureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n8solution/selective_disclosure/selective_disclosure.proto\x12+com.weba\
    nk.wedpr.selective_disclosure.proto\"8\n\x11AttributeTemplate\x12#\n\rat\
    tribute_key\x18\x01\x20\x03(\tR\x0cattributeKey\"<\n\x12StringToStringPa\
    ir\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\"\xa9\x02\n\x12CredentialTemplate\x12k\n\x11cr\
    edential_schema\x18\x01\x20\x01(\x0b2>.com.webank.wedpr.selective_disclo\
    sure.proto.AttributeTemplateR\x10credentialSchema\x12G\n\x20credential_k\
    ey_correctness_proof\x18\x02\x20\x01(\tR\x1dcredentialKeyCorrectnessProo\
    f\x12]\n\npublic_key\x18\x03\x20\x01(\x0b2>.com.webank.wedpr.selective_d\
    isclosure.proto.TemplatePublicKeyR\tpublicKey\"G\n\x11TemplatePublicKey\
    \x122\n\x15credential_public_key\x18\x01\x20\x01(\tR\x13credentialPublic\
    Key\"G\n\x11TemplateSecretKey\x122\n\x15credential_secret_key\x18\x01\
    \x20\x01(\tR\x13credentialSecretKey\"x\n\x0eCredentialInfo\x12f\n\x0eatt\
    ribute_pair\x18\x01\x20\x03(\x0b2?.com.webank.wedpr.selective_disclosure\
    .proto.StringToStringPairR\rattributePair\"\xb7\x01\n\x17BlindedCredenti\
    alSecret\x12<\n\x1ablinded_credential_secrets\x18\x01\x20\x01(\tR\x18bli\
    ndedCredentialSecrets\x12^\n,blinded_credential_secrets_correctness_proo\
    f\x18\x02\x20\x01(\tR(blindedCredentialSecretsCorrectnessProof\"\x88\x01\
    \n\x13CredentialSignature\x121\n\x14credential_signature\x18\x01\x20\x01\
    (\tR\x13credentialSignature\x12>\n\x1bsignature_correctness_proof\x18\
    \x02\x20\x01(\tR\x19signatureCorrectnessProof\"o\n\tPredicate\x12%\n\x0e\
    attribute_name\x18\x01\x20\x01(\tR\rattributeName\x12%\n\x0epredicate_ty\
    pe\x18\x02\x20\x01(\tR\rpredicateType\x12\x14\n\x05value\x18\x03\x20\x01\
    (\x04R\x05value\"\xaa\x01\n\x10VerificationRule\x12-\n\x12revealed_attri\
    bute\x18\x01\x20\x03(\tR\x11revealedAttribute\x12g\n\x13predicate_attrib\
    ute\x18\x02\x20\x03(\x0b26.com.webank.wedpr.selective_disclosure.proto.P\
    redicateR\x12predicateAttribute\"l\n\x15RevealedAttributeInfo\x12S\n\x04\
    attr\x18\x01\x20\x03(\x0b2?.com.webank.wedpr.selective_disclosure.proto.\
    StringToStringPairR\x04attr\"\xa0\x02\n\x1aCredentialSignatureRequest\
    \x12d\n\x0fcredential_info\x18\x01\x20\x01(\x0b2;.com.webank.wedpr.selec\
    tive_disclosure.proto.CredentialInfoR\x0ecredentialInfo\x12<\n\x1ablinde\
    d_credential_secrets\x18\x02\x20\x01(\tR\x18blindedCredentialSecrets\x12\
    ^\n,blinded_credential_secrets_correctness_proof\x18\x03\x20\x01(\tR(bli\
    ndedCredentialSecretsCorrectnessProof\"\xe5\x01\n\x13VerificationRequest\
    \x12p\n\x13credential_template\x18\x01\x20\x01(\x0b2?.com.webank.wedpr.s\
    elective_disclosure.proto.CredentialTemplateR\x12credentialTemplate\x12-\
    \n\x12verification_proof\x18\x02\x20\x01(\tR\x11verificationProof\x12-\n\
    \x12verification_nonce\x18\x03\x20\x01(\tR\x11verificationNonce\"\xbc\
    \x07\n\x19SelectiveDisclosureResult\x12p\n\x13credential_template\x18\
    \x01\x20\x01(\x0b2?.com.webank.wedpr.selective_disclosure.proto.Credenti\
    alTemplateR\x12credentialTemplate\x12n\n\x13template_secret_key\x18\x02\
    \x20\x01(\x0b2>.com.webank.wedpr.selective_disclosure.proto.TemplateSecr\
    etKeyR\x11templateSecretKey\x12s\n\x14credential_signature\x18\x03\x20\
    \x01(\x0b2@.com.webank.wedpr.selective_disclosure.proto.CredentialSignat\
    ureR\x13credentialSignature\x12\x14\n\x05nonce\x18\x04\x20\x01(\tR\x05no\
    nce\x12\x89\x01\n\x1ccredential_signature_request\x18\x05\x20\x01(\x0b2G\
    .com.webank.wedpr.selective_disclosure.proto.CredentialSignatureRequestR\
    \x1acredentialSignatureRequest\x12#\n\rmaster_secret\x18\x06\x20\x01(\tR\
    \x0cmasterSecret\x12M\n#credential_secrets_blinding_factors\x18\x07\x20\
    \x01(\tR\x20credentialSecretsBlindingFactors\x12)\n\x10nonce_credential\
    \x18\x08\x20\x01(\tR\x0fnonceCredential\x12s\n\x14verification_request\
    \x18\t\x20\x01(\x0b2@.com.webank.wedpr.selective_disclosure.proto.Verifi\
    cationRequestR\x13verificationRequest\x12z\n\x17revealed_attribute_info\
    \x18\n\x20\x01(\x0b2B.com.webank.wedpr.selective_disclosure.proto.Reveal\
    edAttributeInfoR\x15revealedAttributeInfo\x12\x16\n\x06result\x18\x0b\
    \x20\x01(\x08R\x06resultB.\n*com.webank.wedpr.selectivedisclosure.protoP\
    \x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<
    ::protobuf::descriptor::FileDescriptorProto,
> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto(
) -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| parse_descriptor_proto())
}
