// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `solution/acv/acv.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct CandidateList {
    // message fields
    pub candidate: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CandidateList {
    fn default() -> &'a CandidateList {
        <CandidateList as ::protobuf::Message>::default_instance()
    }
}

impl CandidateList {
    pub fn new() -> CandidateList {
        ::std::default::Default::default()
    }

    // repeated string candidate = 1;


    pub fn get_candidate(&self) -> &[::std::string::String] {
        &self.candidate
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.candidate = v;
    }

    // Mutable pointer to the field.
    pub fn mut_candidate(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.candidate
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.candidate, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CandidateList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.candidate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.candidate {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.candidate {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CandidateList {
        CandidateList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "candidate",
                |m: &CandidateList| { &m.candidate },
                |m: &mut CandidateList| { &mut m.candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CandidateList>(
                "CandidateList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CandidateList {
        static instance: ::protobuf::rt::LazyV2<CandidateList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CandidateList::new)
    }
}

impl ::protobuf::Clear for CandidateList {
    fn clear(&mut self) {
        self.candidate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CandidateList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CandidateList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PollParametersStorage {
    // message fields
    pub poll_point: ::std::vec::Vec<u8>,
    pub candidates: ::protobuf::SingularPtrField<CandidateList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PollParametersStorage {
    fn default() -> &'a PollParametersStorage {
        <PollParametersStorage as ::protobuf::Message>::default_instance()
    }
}

impl PollParametersStorage {
    pub fn new() -> PollParametersStorage {
        ::std::default::Default::default()
    }

    // bytes poll_point = 1;


    pub fn get_poll_point(&self) -> &[u8] {
        &self.poll_point
    }
    pub fn clear_poll_point(&mut self) {
        self.poll_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_poll_point(&mut self, v: ::std::vec::Vec<u8>) {
        self.poll_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poll_point(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.poll_point
    }

    // Take field
    pub fn take_poll_point(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.poll_point, ::std::vec::Vec::new())
    }

    // .com.webank.wedpr.acv.proto.CandidateList candidates = 2;


    pub fn get_candidates(&self) -> &CandidateList {
        self.candidates.as_ref().unwrap_or_else(|| <CandidateList as ::protobuf::Message>::default_instance())
    }
    pub fn clear_candidates(&mut self) {
        self.candidates.clear();
    }

    pub fn has_candidates(&self) -> bool {
        self.candidates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidates(&mut self, v: CandidateList) {
        self.candidates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidates(&mut self) -> &mut CandidateList {
        if self.candidates.is_none() {
            self.candidates.set_default();
        }
        self.candidates.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidates(&mut self) -> CandidateList {
        self.candidates.take().unwrap_or_else(|| CandidateList::new())
    }
}

impl ::protobuf::Message for PollParametersStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.candidates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.poll_point)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.candidates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.poll_point.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.poll_point);
        }
        if let Some(ref v) = self.candidates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.poll_point.is_empty() {
            os.write_bytes(1, &self.poll_point)?;
        }
        if let Some(ref v) = self.candidates.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PollParametersStorage {
        PollParametersStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "poll_point",
                |m: &PollParametersStorage| { &m.poll_point },
                |m: &mut PollParametersStorage| { &mut m.poll_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CandidateList>>(
                "candidates",
                |m: &PollParametersStorage| { &m.candidates },
                |m: &mut PollParametersStorage| { &mut m.candidates },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PollParametersStorage>(
                "PollParametersStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PollParametersStorage {
        static instance: ::protobuf::rt::LazyV2<PollParametersStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PollParametersStorage::new)
    }
}

impl ::protobuf::Clear for PollParametersStorage {
    fn clear(&mut self) {
        self.poll_point.clear();
        self.candidates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PollParametersStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollParametersStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CounterSecret {
    // message fields
    pub poll_secret_share: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterSecret {
    fn default() -> &'a CounterSecret {
        <CounterSecret as ::protobuf::Message>::default_instance()
    }
}

impl CounterSecret {
    pub fn new() -> CounterSecret {
        ::std::default::Default::default()
    }

    // bytes poll_secret_share = 1;


    pub fn get_poll_secret_share(&self) -> &[u8] {
        &self.poll_secret_share
    }
    pub fn clear_poll_secret_share(&mut self) {
        self.poll_secret_share.clear();
    }

    // Param is passed by value, moved
    pub fn set_poll_secret_share(&mut self, v: ::std::vec::Vec<u8>) {
        self.poll_secret_share = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poll_secret_share(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.poll_secret_share
    }

    // Take field
    pub fn take_poll_secret_share(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.poll_secret_share, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CounterSecret {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.poll_secret_share)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.poll_secret_share.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.poll_secret_share);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.poll_secret_share.is_empty() {
            os.write_bytes(1, &self.poll_secret_share)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterSecret {
        CounterSecret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "poll_secret_share",
                |m: &CounterSecret| { &m.poll_secret_share },
                |m: &mut CounterSecret| { &mut m.poll_secret_share },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterSecret>(
                "CounterSecret",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterSecret {
        static instance: ::protobuf::rt::LazyV2<CounterSecret> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterSecret::new)
    }
}

impl ::protobuf::Clear for CounterSecret {
    fn clear(&mut self) {
        self.poll_secret_share.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterSecret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterSecret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoterSecret {
    // message fields
    pub voter_secret: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoterSecret {
    fn default() -> &'a VoterSecret {
        <VoterSecret as ::protobuf::Message>::default_instance()
    }
}

impl VoterSecret {
    pub fn new() -> VoterSecret {
        ::std::default::Default::default()
    }

    // bytes voter_secret = 1;


    pub fn get_voter_secret(&self) -> &[u8] {
        &self.voter_secret
    }
    pub fn clear_voter_secret(&mut self) {
        self.voter_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_voter_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.voter_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voter_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.voter_secret
    }

    // Take field
    pub fn take_voter_secret(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.voter_secret, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VoterSecret {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.voter_secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.voter_secret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.voter_secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.voter_secret.is_empty() {
            os.write_bytes(1, &self.voter_secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoterSecret {
        VoterSecret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "voter_secret",
                |m: &VoterSecret| { &m.voter_secret },
                |m: &mut VoterSecret| { &mut m.voter_secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoterSecret>(
                "VoterSecret",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoterSecret {
        static instance: ::protobuf::rt::LazyV2<VoterSecret> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoterSecret::new)
    }
}

impl ::protobuf::Clear for VoterSecret {
    fn clear(&mut self) {
        self.voter_secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoterSecret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoterSecret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegistrationRequest {
    // message fields
    pub weight_point: ::protobuf::SingularPtrField<RegistrationBlindingPoint>,
    pub zero_point: ::protobuf::SingularPtrField<RegistrationBlindingPoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegistrationRequest {
    fn default() -> &'a RegistrationRequest {
        <RegistrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationRequest {
    pub fn new() -> RegistrationRequest {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.acv.proto.RegistrationBlindingPoint weight_point = 1;


    pub fn get_weight_point(&self) -> &RegistrationBlindingPoint {
        self.weight_point.as_ref().unwrap_or_else(|| <RegistrationBlindingPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_weight_point(&mut self) {
        self.weight_point.clear();
    }

    pub fn has_weight_point(&self) -> bool {
        self.weight_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight_point(&mut self, v: RegistrationBlindingPoint) {
        self.weight_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weight_point(&mut self) -> &mut RegistrationBlindingPoint {
        if self.weight_point.is_none() {
            self.weight_point.set_default();
        }
        self.weight_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_weight_point(&mut self) -> RegistrationBlindingPoint {
        self.weight_point.take().unwrap_or_else(|| RegistrationBlindingPoint::new())
    }

    // .com.webank.wedpr.acv.proto.RegistrationBlindingPoint zero_point = 2;


    pub fn get_zero_point(&self) -> &RegistrationBlindingPoint {
        self.zero_point.as_ref().unwrap_or_else(|| <RegistrationBlindingPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_zero_point(&mut self) {
        self.zero_point.clear();
    }

    pub fn has_zero_point(&self) -> bool {
        self.zero_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zero_point(&mut self, v: RegistrationBlindingPoint) {
        self.zero_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zero_point(&mut self) -> &mut RegistrationBlindingPoint {
        if self.zero_point.is_none() {
            self.zero_point.set_default();
        }
        self.zero_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_zero_point(&mut self) -> RegistrationBlindingPoint {
        self.zero_point.take().unwrap_or_else(|| RegistrationBlindingPoint::new())
    }
}

impl ::protobuf::Message for RegistrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.weight_point {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.zero_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.weight_point)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.zero_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.weight_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.zero_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.weight_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.zero_point.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegistrationRequest {
        RegistrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegistrationBlindingPoint>>(
                "weight_point",
                |m: &RegistrationRequest| { &m.weight_point },
                |m: &mut RegistrationRequest| { &mut m.weight_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegistrationBlindingPoint>>(
                "zero_point",
                |m: &RegistrationRequest| { &m.zero_point },
                |m: &mut RegistrationRequest| { &mut m.zero_point },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegistrationRequest>(
                "RegistrationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegistrationRequest {
        static instance: ::protobuf::rt::LazyV2<RegistrationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegistrationRequest::new)
    }
}

impl ::protobuf::Clear for RegistrationRequest {
    fn clear(&mut self) {
        self.weight_point.clear();
        self.zero_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegistrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegistrationBlindingPoint {
    // message fields
    pub blinding_poll_point: ::std::vec::Vec<u8>,
    pub blinding_basepoint_g2: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegistrationBlindingPoint {
    fn default() -> &'a RegistrationBlindingPoint {
        <RegistrationBlindingPoint as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationBlindingPoint {
    pub fn new() -> RegistrationBlindingPoint {
        ::std::default::Default::default()
    }

    // bytes blinding_poll_point = 1;


    pub fn get_blinding_poll_point(&self) -> &[u8] {
        &self.blinding_poll_point
    }
    pub fn clear_blinding_poll_point(&mut self) {
        self.blinding_poll_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinding_poll_point(&mut self, v: ::std::vec::Vec<u8>) {
        self.blinding_poll_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinding_poll_point(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blinding_poll_point
    }

    // Take field
    pub fn take_blinding_poll_point(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blinding_poll_point, ::std::vec::Vec::new())
    }

    // bytes blinding_basepoint_g2 = 2;


    pub fn get_blinding_basepoint_g2(&self) -> &[u8] {
        &self.blinding_basepoint_g2
    }
    pub fn clear_blinding_basepoint_g2(&mut self) {
        self.blinding_basepoint_g2.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinding_basepoint_g2(&mut self, v: ::std::vec::Vec<u8>) {
        self.blinding_basepoint_g2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinding_basepoint_g2(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blinding_basepoint_g2
    }

    // Take field
    pub fn take_blinding_basepoint_g2(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blinding_basepoint_g2, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RegistrationBlindingPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blinding_poll_point)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blinding_basepoint_g2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blinding_poll_point.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.blinding_poll_point);
        }
        if !self.blinding_basepoint_g2.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.blinding_basepoint_g2);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.blinding_poll_point.is_empty() {
            os.write_bytes(1, &self.blinding_poll_point)?;
        }
        if !self.blinding_basepoint_g2.is_empty() {
            os.write_bytes(2, &self.blinding_basepoint_g2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegistrationBlindingPoint {
        RegistrationBlindingPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blinding_poll_point",
                |m: &RegistrationBlindingPoint| { &m.blinding_poll_point },
                |m: &mut RegistrationBlindingPoint| { &mut m.blinding_poll_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blinding_basepoint_g2",
                |m: &RegistrationBlindingPoint| { &m.blinding_basepoint_g2 },
                |m: &mut RegistrationBlindingPoint| { &mut m.blinding_basepoint_g2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegistrationBlindingPoint>(
                "RegistrationBlindingPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegistrationBlindingPoint {
        static instance: ::protobuf::rt::LazyV2<RegistrationBlindingPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegistrationBlindingPoint::new)
    }
}

impl ::protobuf::Clear for RegistrationBlindingPoint {
    fn clear(&mut self) {
        self.blinding_poll_point.clear();
        self.blinding_basepoint_g2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegistrationBlindingPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationBlindingPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegistrationResponse {
    // message fields
    pub voter_weight: u32,
    pub ballot: ::protobuf::SingularPtrField<Ballot>,
    pub signature: ::std::vec::Vec<u8>,
    pub zero_ballot: ::protobuf::SingularPtrField<Ballot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegistrationResponse {
    fn default() -> &'a RegistrationResponse {
        <RegistrationResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationResponse {
    pub fn new() -> RegistrationResponse {
        ::std::default::Default::default()
    }

    // uint32 voter_weight = 1;


    pub fn get_voter_weight(&self) -> u32 {
        self.voter_weight
    }
    pub fn clear_voter_weight(&mut self) {
        self.voter_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_voter_weight(&mut self, v: u32) {
        self.voter_weight = v;
    }

    // .com.webank.wedpr.acv.proto.Ballot ballot = 2;


    pub fn get_ballot(&self) -> &Ballot {
        self.ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: Ballot) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut Ballot {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> Ballot {
        self.ballot.take().unwrap_or_else(|| Ballot::new())
    }

    // bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // .com.webank.wedpr.acv.proto.Ballot zero_ballot = 4;


    pub fn get_zero_ballot(&self) -> &Ballot {
        self.zero_ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_zero_ballot(&mut self) {
        self.zero_ballot.clear();
    }

    pub fn has_zero_ballot(&self) -> bool {
        self.zero_ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zero_ballot(&mut self, v: Ballot) {
        self.zero_ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zero_ballot(&mut self) -> &mut Ballot {
        if self.zero_ballot.is_none() {
            self.zero_ballot.set_default();
        }
        self.zero_ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_zero_ballot(&mut self) -> Ballot {
        self.zero_ballot.take().unwrap_or_else(|| Ballot::new())
    }
}

impl ::protobuf::Message for RegistrationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.zero_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.voter_weight = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.zero_ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.voter_weight != 0 {
            my_size += ::protobuf::rt::value_size(1, self.voter_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if let Some(ref v) = self.zero_ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.voter_weight != 0 {
            os.write_uint32(1, self.voter_weight)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if let Some(ref v) = self.zero_ballot.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegistrationResponse {
        RegistrationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "voter_weight",
                |m: &RegistrationResponse| { &m.voter_weight },
                |m: &mut RegistrationResponse| { &mut m.voter_weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "ballot",
                |m: &RegistrationResponse| { &m.ballot },
                |m: &mut RegistrationResponse| { &mut m.ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &RegistrationResponse| { &m.signature },
                |m: &mut RegistrationResponse| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "zero_ballot",
                |m: &RegistrationResponse| { &m.zero_ballot },
                |m: &mut RegistrationResponse| { &mut m.zero_ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegistrationResponse>(
                "RegistrationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegistrationResponse {
        static instance: ::protobuf::rt::LazyV2<RegistrationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegistrationResponse::new)
    }
}

impl ::protobuf::Clear for RegistrationResponse {
    fn clear(&mut self) {
        self.voter_weight = 0;
        self.ballot.clear();
        self.signature.clear();
        self.zero_ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegistrationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ballot {
    // message fields
    pub ciphertext1: ::std::vec::Vec<u8>,
    pub ciphertext2: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ballot {
    fn default() -> &'a Ballot {
        <Ballot as ::protobuf::Message>::default_instance()
    }
}

impl Ballot {
    pub fn new() -> Ballot {
        ::std::default::Default::default()
    }

    // bytes ciphertext1 = 1;


    pub fn get_ciphertext1(&self) -> &[u8] {
        &self.ciphertext1
    }
    pub fn clear_ciphertext1(&mut self) {
        self.ciphertext1.clear();
    }

    // Param is passed by value, moved
    pub fn set_ciphertext1(&mut self, v: ::std::vec::Vec<u8>) {
        self.ciphertext1 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ciphertext1(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ciphertext1
    }

    // Take field
    pub fn take_ciphertext1(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ciphertext1, ::std::vec::Vec::new())
    }

    // bytes ciphertext2 = 2;


    pub fn get_ciphertext2(&self) -> &[u8] {
        &self.ciphertext2
    }
    pub fn clear_ciphertext2(&mut self) {
        self.ciphertext2.clear();
    }

    // Param is passed by value, moved
    pub fn set_ciphertext2(&mut self, v: ::std::vec::Vec<u8>) {
        self.ciphertext2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ciphertext2(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ciphertext2
    }

    // Take field
    pub fn take_ciphertext2(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ciphertext2, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Ballot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ciphertext1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ciphertext2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ciphertext1.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ciphertext1);
        }
        if !self.ciphertext2.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ciphertext2);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ciphertext1.is_empty() {
            os.write_bytes(1, &self.ciphertext1)?;
        }
        if !self.ciphertext2.is_empty() {
            os.write_bytes(2, &self.ciphertext2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ballot {
        Ballot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ciphertext1",
                |m: &Ballot| { &m.ciphertext1 },
                |m: &mut Ballot| { &mut m.ciphertext1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ciphertext2",
                |m: &Ballot| { &m.ciphertext2 },
                |m: &mut Ballot| { &mut m.ciphertext2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ballot>(
                "Ballot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ballot {
        static instance: ::protobuf::rt::LazyV2<Ballot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ballot::new)
    }
}

impl ::protobuf::Clear for Ballot {
    fn clear(&mut self) {
        self.ciphertext1.clear();
        self.ciphertext2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ballot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ballot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CounterParametersShareRequest {
    // message fields
    pub counter_id: ::std::string::String,
    pub poll_point_share: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterParametersShareRequest {
    fn default() -> &'a CounterParametersShareRequest {
        <CounterParametersShareRequest as ::protobuf::Message>::default_instance()
    }
}

impl CounterParametersShareRequest {
    pub fn new() -> CounterParametersShareRequest {
        ::std::default::Default::default()
    }

    // string counter_id = 1;


    pub fn get_counter_id(&self) -> &str {
        &self.counter_id
    }
    pub fn clear_counter_id(&mut self) {
        self.counter_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_id(&mut self, v: ::std::string::String) {
        self.counter_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_id(&mut self) -> &mut ::std::string::String {
        &mut self.counter_id
    }

    // Take field
    pub fn take_counter_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.counter_id, ::std::string::String::new())
    }

    // bytes poll_point_share = 2;


    pub fn get_poll_point_share(&self) -> &[u8] {
        &self.poll_point_share
    }
    pub fn clear_poll_point_share(&mut self) {
        self.poll_point_share.clear();
    }

    // Param is passed by value, moved
    pub fn set_poll_point_share(&mut self, v: ::std::vec::Vec<u8>) {
        self.poll_point_share = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poll_point_share(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.poll_point_share
    }

    // Take field
    pub fn take_poll_point_share(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.poll_point_share, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CounterParametersShareRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.counter_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.poll_point_share)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.counter_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.counter_id);
        }
        if !self.poll_point_share.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.poll_point_share);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.counter_id.is_empty() {
            os.write_string(1, &self.counter_id)?;
        }
        if !self.poll_point_share.is_empty() {
            os.write_bytes(2, &self.poll_point_share)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterParametersShareRequest {
        CounterParametersShareRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "counter_id",
                |m: &CounterParametersShareRequest| { &m.counter_id },
                |m: &mut CounterParametersShareRequest| { &mut m.counter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "poll_point_share",
                |m: &CounterParametersShareRequest| { &m.poll_point_share },
                |m: &mut CounterParametersShareRequest| { &mut m.poll_point_share },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterParametersShareRequest>(
                "CounterParametersShareRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterParametersShareRequest {
        static instance: ::protobuf::rt::LazyV2<CounterParametersShareRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterParametersShareRequest::new)
    }
}

impl ::protobuf::Clear for CounterParametersShareRequest {
    fn clear(&mut self) {
        self.counter_id.clear();
        self.poll_point_share.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterParametersShareRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterParametersShareRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CounterParametersStorage {
    // message fields
    pub counter_parameters_share: ::protobuf::RepeatedField<CounterParametersShareRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterParametersStorage {
    fn default() -> &'a CounterParametersStorage {
        <CounterParametersStorage as ::protobuf::Message>::default_instance()
    }
}

impl CounterParametersStorage {
    pub fn new() -> CounterParametersStorage {
        ::std::default::Default::default()
    }

    // repeated .com.webank.wedpr.acv.proto.CounterParametersShareRequest counter_parameters_share = 1;


    pub fn get_counter_parameters_share(&self) -> &[CounterParametersShareRequest] {
        &self.counter_parameters_share
    }
    pub fn clear_counter_parameters_share(&mut self) {
        self.counter_parameters_share.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_parameters_share(&mut self, v: ::protobuf::RepeatedField<CounterParametersShareRequest>) {
        self.counter_parameters_share = v;
    }

    // Mutable pointer to the field.
    pub fn mut_counter_parameters_share(&mut self) -> &mut ::protobuf::RepeatedField<CounterParametersShareRequest> {
        &mut self.counter_parameters_share
    }

    // Take field
    pub fn take_counter_parameters_share(&mut self) -> ::protobuf::RepeatedField<CounterParametersShareRequest> {
        ::std::mem::replace(&mut self.counter_parameters_share, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CounterParametersStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.counter_parameters_share {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.counter_parameters_share)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.counter_parameters_share {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.counter_parameters_share {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterParametersStorage {
        CounterParametersStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CounterParametersShareRequest>>(
                "counter_parameters_share",
                |m: &CounterParametersStorage| { &m.counter_parameters_share },
                |m: &mut CounterParametersStorage| { &mut m.counter_parameters_share },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterParametersStorage>(
                "CounterParametersStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterParametersStorage {
        static instance: ::protobuf::rt::LazyV2<CounterParametersStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterParametersStorage::new)
    }
}

impl ::protobuf::Clear for CounterParametersStorage {
    fn clear(&mut self) {
        self.counter_parameters_share.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterParametersStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterParametersStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteChoice {
    // message fields
    pub candidate: ::std::string::String,
    pub value: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteChoice {
    fn default() -> &'a VoteChoice {
        <VoteChoice as ::protobuf::Message>::default_instance()
    }
}

impl VoteChoice {
    pub fn new() -> VoteChoice {
        ::std::default::Default::default()
    }

    // string candidate = 1;


    pub fn get_candidate(&self) -> &str {
        &self.candidate
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        &mut self.candidate
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.candidate, ::std::string::String::new())
    }

    // uint32 value = 2;


    pub fn get_value(&self) -> u32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }
}

impl ::protobuf::Message for VoteChoice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.candidate)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.candidate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.candidate);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.candidate.is_empty() {
            os.write_string(1, &self.candidate)?;
        }
        if self.value != 0 {
            os.write_uint32(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteChoice {
        VoteChoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "candidate",
                |m: &VoteChoice| { &m.candidate },
                |m: &mut VoteChoice| { &mut m.candidate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "value",
                |m: &VoteChoice| { &m.value },
                |m: &mut VoteChoice| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteChoice>(
                "VoteChoice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteChoice {
        static instance: ::protobuf::rt::LazyV2<VoteChoice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteChoice::new)
    }
}

impl ::protobuf::Clear for VoteChoice {
    fn clear(&mut self) {
        self.candidate.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteChoice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnlistedVoteChoice {
    // message fields
    pub candidate_id: u32,
    pub value: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnlistedVoteChoice {
    fn default() -> &'a UnlistedVoteChoice {
        <UnlistedVoteChoice as ::protobuf::Message>::default_instance()
    }
}

impl UnlistedVoteChoice {
    pub fn new() -> UnlistedVoteChoice {
        ::std::default::Default::default()
    }

    // uint32 candidate_id = 1;


    pub fn get_candidate_id(&self) -> u32 {
        self.candidate_id
    }
    pub fn clear_candidate_id(&mut self) {
        self.candidate_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_candidate_id(&mut self, v: u32) {
        self.candidate_id = v;
    }

    // uint32 value = 2;


    pub fn get_value(&self) -> u32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }
}

impl ::protobuf::Message for UnlistedVoteChoice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.candidate_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.candidate_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.candidate_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.candidate_id != 0 {
            os.write_uint32(1, self.candidate_id)?;
        }
        if self.value != 0 {
            os.write_uint32(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnlistedVoteChoice {
        UnlistedVoteChoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "candidate_id",
                |m: &UnlistedVoteChoice| { &m.candidate_id },
                |m: &mut UnlistedVoteChoice| { &mut m.candidate_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "value",
                |m: &UnlistedVoteChoice| { &m.value },
                |m: &mut UnlistedVoteChoice| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnlistedVoteChoice>(
                "UnlistedVoteChoice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnlistedVoteChoice {
        static instance: ::protobuf::rt::LazyV2<UnlistedVoteChoice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnlistedVoteChoice::new)
    }
}

impl ::protobuf::Clear for UnlistedVoteChoice {
    fn clear(&mut self) {
        self.candidate_id = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlistedVoteChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlistedVoteChoice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteChoices {
    // message fields
    pub choice: ::protobuf::RepeatedField<VoteChoice>,
    pub unlisted_choice: ::protobuf::RepeatedField<UnlistedVoteChoice>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteChoices {
    fn default() -> &'a VoteChoices {
        <VoteChoices as ::protobuf::Message>::default_instance()
    }
}

impl VoteChoices {
    pub fn new() -> VoteChoices {
        ::std::default::Default::default()
    }

    // repeated .com.webank.wedpr.acv.proto.VoteChoice choice = 1;


    pub fn get_choice(&self) -> &[VoteChoice] {
        &self.choice
    }
    pub fn clear_choice(&mut self) {
        self.choice.clear();
    }

    // Param is passed by value, moved
    pub fn set_choice(&mut self, v: ::protobuf::RepeatedField<VoteChoice>) {
        self.choice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choice(&mut self) -> &mut ::protobuf::RepeatedField<VoteChoice> {
        &mut self.choice
    }

    // Take field
    pub fn take_choice(&mut self) -> ::protobuf::RepeatedField<VoteChoice> {
        ::std::mem::replace(&mut self.choice, ::protobuf::RepeatedField::new())
    }

    // repeated .com.webank.wedpr.acv.proto.UnlistedVoteChoice unlisted_choice = 2;


    pub fn get_unlisted_choice(&self) -> &[UnlistedVoteChoice] {
        &self.unlisted_choice
    }
    pub fn clear_unlisted_choice(&mut self) {
        self.unlisted_choice.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlisted_choice(&mut self, v: ::protobuf::RepeatedField<UnlistedVoteChoice>) {
        self.unlisted_choice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlisted_choice(&mut self) -> &mut ::protobuf::RepeatedField<UnlistedVoteChoice> {
        &mut self.unlisted_choice
    }

    // Take field
    pub fn take_unlisted_choice(&mut self) -> ::protobuf::RepeatedField<UnlistedVoteChoice> {
        ::std::mem::replace(&mut self.unlisted_choice, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VoteChoices {
    fn is_initialized(&self) -> bool {
        for v in &self.choice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlisted_choice {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.choice)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlisted_choice)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.choice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unlisted_choice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.choice {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unlisted_choice {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteChoices {
        VoteChoices::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoteChoice>>(
                "choice",
                |m: &VoteChoices| { &m.choice },
                |m: &mut VoteChoices| { &mut m.choice },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnlistedVoteChoice>>(
                "unlisted_choice",
                |m: &VoteChoices| { &m.unlisted_choice },
                |m: &mut VoteChoices| { &mut m.unlisted_choice },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteChoices>(
                "VoteChoices",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteChoices {
        static instance: ::protobuf::rt::LazyV2<VoteChoices> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteChoices::new)
    }
}

impl ::protobuf::Clear for VoteChoices {
    fn clear(&mut self) {
        self.choice.clear();
        self.unlisted_choice.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteChoices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteChoices {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CandidateBallot {
    // message fields
    pub candidate: ::std::string::String,
    pub ballot: ::protobuf::SingularPtrField<Ballot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CandidateBallot {
    fn default() -> &'a CandidateBallot {
        <CandidateBallot as ::protobuf::Message>::default_instance()
    }
}

impl CandidateBallot {
    pub fn new() -> CandidateBallot {
        ::std::default::Default::default()
    }

    // string candidate = 1;


    pub fn get_candidate(&self) -> &str {
        &self.candidate
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        &mut self.candidate
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.candidate, ::std::string::String::new())
    }

    // .com.webank.wedpr.acv.proto.Ballot ballot = 2;


    pub fn get_ballot(&self) -> &Ballot {
        self.ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: Ballot) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut Ballot {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> Ballot {
        self.ballot.take().unwrap_or_else(|| Ballot::new())
    }
}

impl ::protobuf::Message for CandidateBallot {
    fn is_initialized(&self) -> bool {
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.candidate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.candidate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.candidate);
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.candidate.is_empty() {
            os.write_string(1, &self.candidate)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CandidateBallot {
        CandidateBallot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "candidate",
                |m: &CandidateBallot| { &m.candidate },
                |m: &mut CandidateBallot| { &mut m.candidate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "ballot",
                |m: &CandidateBallot| { &m.ballot },
                |m: &mut CandidateBallot| { &mut m.ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CandidateBallot>(
                "CandidateBallot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CandidateBallot {
        static instance: ::protobuf::rt::LazyV2<CandidateBallot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CandidateBallot::new)
    }
}

impl ::protobuf::Clear for CandidateBallot {
    fn clear(&mut self) {
        self.candidate.clear();
        self.ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CandidateBallot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CandidateBallot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BallotProof {
    // message fields
    pub format_proof: ::std::vec::Vec<u8>,
    pub either_equality_proof: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BallotProof {
    fn default() -> &'a BallotProof {
        <BallotProof as ::protobuf::Message>::default_instance()
    }
}

impl BallotProof {
    pub fn new() -> BallotProof {
        ::std::default::Default::default()
    }

    // bytes format_proof = 1;


    pub fn get_format_proof(&self) -> &[u8] {
        &self.format_proof
    }
    pub fn clear_format_proof(&mut self) {
        self.format_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_format_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.format_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.format_proof
    }

    // Take field
    pub fn take_format_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.format_proof, ::std::vec::Vec::new())
    }

    // bytes either_equality_proof = 2;


    pub fn get_either_equality_proof(&self) -> &[u8] {
        &self.either_equality_proof
    }
    pub fn clear_either_equality_proof(&mut self) {
        self.either_equality_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_either_equality_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.either_equality_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_either_equality_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.either_equality_proof
    }

    // Take field
    pub fn take_either_equality_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.either_equality_proof, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BallotProof {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.format_proof)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.either_equality_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.format_proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.format_proof);
        }
        if !self.either_equality_proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.either_equality_proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.format_proof.is_empty() {
            os.write_bytes(1, &self.format_proof)?;
        }
        if !self.either_equality_proof.is_empty() {
            os.write_bytes(2, &self.either_equality_proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BallotProof {
        BallotProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "format_proof",
                |m: &BallotProof| { &m.format_proof },
                |m: &mut BallotProof| { &mut m.format_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "either_equality_proof",
                |m: &BallotProof| { &m.either_equality_proof },
                |m: &mut BallotProof| { &mut m.either_equality_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BallotProof>(
                "BallotProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BallotProof {
        static instance: ::protobuf::rt::LazyV2<BallotProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BallotProof::new)
    }
}

impl ::protobuf::Clear for BallotProof {
    fn clear(&mut self) {
        self.format_proof.clear();
        self.either_equality_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BallotProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BallotProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringToBallotProofPair {
    // message fields
    pub key: ::std::string::String,
    pub value: ::protobuf::SingularPtrField<BallotProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringToBallotProofPair {
    fn default() -> &'a StringToBallotProofPair {
        <StringToBallotProofPair as ::protobuf::Message>::default_instance()
    }
}

impl StringToBallotProofPair {
    pub fn new() -> StringToBallotProofPair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // .com.webank.wedpr.acv.proto.BallotProof value = 2;


    pub fn get_value(&self) -> &BallotProof {
        self.value.as_ref().unwrap_or_else(|| <BallotProof as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: BallotProof) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut BallotProof {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> BallotProof {
        self.value.take().unwrap_or_else(|| BallotProof::new())
    }
}

impl ::protobuf::Message for StringToBallotProofPair {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringToBallotProofPair {
        StringToBallotProofPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &StringToBallotProofPair| { &m.key },
                |m: &mut StringToBallotProofPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BallotProof>>(
                "value",
                |m: &StringToBallotProofPair| { &m.value },
                |m: &mut StringToBallotProofPair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringToBallotProofPair>(
                "StringToBallotProofPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringToBallotProofPair {
        static instance: ::protobuf::rt::LazyV2<StringToBallotProofPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringToBallotProofPair::new)
    }
}

impl ::protobuf::Clear for StringToBallotProofPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringToBallotProofPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringToBallotProofPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteRequest {
    // message fields
    pub vote: ::protobuf::SingularPtrField<VoteStorage>,
    pub ballot_proof: ::protobuf::RepeatedField<StringToBallotProofPair>,
    pub range_proof: ::std::vec::Vec<u8>,
    pub sum_balance_proof: ::std::vec::Vec<u8>,
    pub unlisted_ballot_proof: ::protobuf::RepeatedField<CipherPointsToBallotProofPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteRequest {
    fn default() -> &'a VoteRequest {
        <VoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl VoteRequest {
    pub fn new() -> VoteRequest {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.acv.proto.VoteStorage vote = 1;


    pub fn get_vote(&self) -> &VoteStorage {
        self.vote.as_ref().unwrap_or_else(|| <VoteStorage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vote(&mut self) {
        self.vote.clear();
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: VoteStorage) {
        self.vote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote(&mut self) -> &mut VoteStorage {
        if self.vote.is_none() {
            self.vote.set_default();
        }
        self.vote.as_mut().unwrap()
    }

    // Take field
    pub fn take_vote(&mut self) -> VoteStorage {
        self.vote.take().unwrap_or_else(|| VoteStorage::new())
    }

    // repeated .com.webank.wedpr.acv.proto.StringToBallotProofPair ballot_proof = 2;


    pub fn get_ballot_proof(&self) -> &[StringToBallotProofPair] {
        &self.ballot_proof
    }
    pub fn clear_ballot_proof(&mut self) {
        self.ballot_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_ballot_proof(&mut self, v: ::protobuf::RepeatedField<StringToBallotProofPair>) {
        self.ballot_proof = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ballot_proof(&mut self) -> &mut ::protobuf::RepeatedField<StringToBallotProofPair> {
        &mut self.ballot_proof
    }

    // Take field
    pub fn take_ballot_proof(&mut self) -> ::protobuf::RepeatedField<StringToBallotProofPair> {
        ::std::mem::replace(&mut self.ballot_proof, ::protobuf::RepeatedField::new())
    }

    // bytes range_proof = 3;


    pub fn get_range_proof(&self) -> &[u8] {
        &self.range_proof
    }
    pub fn clear_range_proof(&mut self) {
        self.range_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_proof
    }

    // Take field
    pub fn take_range_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_proof, ::std::vec::Vec::new())
    }

    // bytes sum_balance_proof = 4;


    pub fn get_sum_balance_proof(&self) -> &[u8] {
        &self.sum_balance_proof
    }
    pub fn clear_sum_balance_proof(&mut self) {
        self.sum_balance_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_sum_balance_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.sum_balance_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sum_balance_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sum_balance_proof
    }

    // Take field
    pub fn take_sum_balance_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sum_balance_proof, ::std::vec::Vec::new())
    }

    // repeated .com.webank.wedpr.acv.proto.CipherPointsToBallotProofPair unlisted_ballot_proof = 5;


    pub fn get_unlisted_ballot_proof(&self) -> &[CipherPointsToBallotProofPair] {
        &self.unlisted_ballot_proof
    }
    pub fn clear_unlisted_ballot_proof(&mut self) {
        self.unlisted_ballot_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlisted_ballot_proof(&mut self, v: ::protobuf::RepeatedField<CipherPointsToBallotProofPair>) {
        self.unlisted_ballot_proof = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlisted_ballot_proof(&mut self) -> &mut ::protobuf::RepeatedField<CipherPointsToBallotProofPair> {
        &mut self.unlisted_ballot_proof
    }

    // Take field
    pub fn take_unlisted_ballot_proof(&mut self) -> ::protobuf::RepeatedField<CipherPointsToBallotProofPair> {
        ::std::mem::replace(&mut self.unlisted_ballot_proof, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VoteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.vote {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlisted_ballot_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vote)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ballot_proof)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_proof)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sum_balance_proof)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlisted_ballot_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ballot_proof {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.range_proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.range_proof);
        }
        if !self.sum_balance_proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.sum_balance_proof);
        }
        for value in &self.unlisted_ballot_proof {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vote.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ballot_proof {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.range_proof.is_empty() {
            os.write_bytes(3, &self.range_proof)?;
        }
        if !self.sum_balance_proof.is_empty() {
            os.write_bytes(4, &self.sum_balance_proof)?;
        }
        for v in &self.unlisted_ballot_proof {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteRequest {
        VoteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoteStorage>>(
                "vote",
                |m: &VoteRequest| { &m.vote },
                |m: &mut VoteRequest| { &mut m.vote },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringToBallotProofPair>>(
                "ballot_proof",
                |m: &VoteRequest| { &m.ballot_proof },
                |m: &mut VoteRequest| { &mut m.ballot_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "range_proof",
                |m: &VoteRequest| { &m.range_proof },
                |m: &mut VoteRequest| { &mut m.range_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sum_balance_proof",
                |m: &VoteRequest| { &m.sum_balance_proof },
                |m: &mut VoteRequest| { &mut m.sum_balance_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CipherPointsToBallotProofPair>>(
                "unlisted_ballot_proof",
                |m: &VoteRequest| { &m.unlisted_ballot_proof },
                |m: &mut VoteRequest| { &mut m.unlisted_ballot_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteRequest>(
                "VoteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteRequest {
        static instance: ::protobuf::rt::LazyV2<VoteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteRequest::new)
    }
}

impl ::protobuf::Clear for VoteRequest {
    fn clear(&mut self) {
        self.vote.clear();
        self.ballot_proof.clear();
        self.range_proof.clear();
        self.sum_balance_proof.clear();
        self.unlisted_ballot_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteStorage {
    // message fields
    pub signature: ::std::vec::Vec<u8>,
    pub blank_ballot: ::protobuf::SingularPtrField<Ballot>,
    pub rest_ballot: ::protobuf::SingularPtrField<Ballot>,
    pub voted_ballot: ::protobuf::RepeatedField<CandidateBallot>,
    pub voted_ballot_unlisted: ::protobuf::RepeatedField<CipherPointsToBallotPair>,
    pub zero_ballot: ::protobuf::SingularPtrField<Ballot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteStorage {
    fn default() -> &'a VoteStorage {
        <VoteStorage as ::protobuf::Message>::default_instance()
    }
}

impl VoteStorage {
    pub fn new() -> VoteStorage {
        ::std::default::Default::default()
    }

    // bytes signature = 1;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // .com.webank.wedpr.acv.proto.Ballot blank_ballot = 2;


    pub fn get_blank_ballot(&self) -> &Ballot {
        self.blank_ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blank_ballot(&mut self) {
        self.blank_ballot.clear();
    }

    pub fn has_blank_ballot(&self) -> bool {
        self.blank_ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blank_ballot(&mut self, v: Ballot) {
        self.blank_ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blank_ballot(&mut self) -> &mut Ballot {
        if self.blank_ballot.is_none() {
            self.blank_ballot.set_default();
        }
        self.blank_ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_blank_ballot(&mut self) -> Ballot {
        self.blank_ballot.take().unwrap_or_else(|| Ballot::new())
    }

    // .com.webank.wedpr.acv.proto.Ballot rest_ballot = 3;


    pub fn get_rest_ballot(&self) -> &Ballot {
        self.rest_ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rest_ballot(&mut self) {
        self.rest_ballot.clear();
    }

    pub fn has_rest_ballot(&self) -> bool {
        self.rest_ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rest_ballot(&mut self, v: Ballot) {
        self.rest_ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rest_ballot(&mut self) -> &mut Ballot {
        if self.rest_ballot.is_none() {
            self.rest_ballot.set_default();
        }
        self.rest_ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_rest_ballot(&mut self) -> Ballot {
        self.rest_ballot.take().unwrap_or_else(|| Ballot::new())
    }

    // repeated .com.webank.wedpr.acv.proto.CandidateBallot voted_ballot = 4;


    pub fn get_voted_ballot(&self) -> &[CandidateBallot] {
        &self.voted_ballot
    }
    pub fn clear_voted_ballot(&mut self) {
        self.voted_ballot.clear();
    }

    // Param is passed by value, moved
    pub fn set_voted_ballot(&mut self, v: ::protobuf::RepeatedField<CandidateBallot>) {
        self.voted_ballot = v;
    }

    // Mutable pointer to the field.
    pub fn mut_voted_ballot(&mut self) -> &mut ::protobuf::RepeatedField<CandidateBallot> {
        &mut self.voted_ballot
    }

    // Take field
    pub fn take_voted_ballot(&mut self) -> ::protobuf::RepeatedField<CandidateBallot> {
        ::std::mem::replace(&mut self.voted_ballot, ::protobuf::RepeatedField::new())
    }

    // repeated .com.webank.wedpr.acv.proto.CipherPointsToBallotPair voted_ballot_unlisted = 6;


    pub fn get_voted_ballot_unlisted(&self) -> &[CipherPointsToBallotPair] {
        &self.voted_ballot_unlisted
    }
    pub fn clear_voted_ballot_unlisted(&mut self) {
        self.voted_ballot_unlisted.clear();
    }

    // Param is passed by value, moved
    pub fn set_voted_ballot_unlisted(&mut self, v: ::protobuf::RepeatedField<CipherPointsToBallotPair>) {
        self.voted_ballot_unlisted = v;
    }

    // Mutable pointer to the field.
    pub fn mut_voted_ballot_unlisted(&mut self) -> &mut ::protobuf::RepeatedField<CipherPointsToBallotPair> {
        &mut self.voted_ballot_unlisted
    }

    // Take field
    pub fn take_voted_ballot_unlisted(&mut self) -> ::protobuf::RepeatedField<CipherPointsToBallotPair> {
        ::std::mem::replace(&mut self.voted_ballot_unlisted, ::protobuf::RepeatedField::new())
    }

    // .com.webank.wedpr.acv.proto.Ballot zero_ballot = 7;


    pub fn get_zero_ballot(&self) -> &Ballot {
        self.zero_ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_zero_ballot(&mut self) {
        self.zero_ballot.clear();
    }

    pub fn has_zero_ballot(&self) -> bool {
        self.zero_ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zero_ballot(&mut self, v: Ballot) {
        self.zero_ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zero_ballot(&mut self) -> &mut Ballot {
        if self.zero_ballot.is_none() {
            self.zero_ballot.set_default();
        }
        self.zero_ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_zero_ballot(&mut self) -> Ballot {
        self.zero_ballot.take().unwrap_or_else(|| Ballot::new())
    }
}

impl ::protobuf::Message for VoteStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.blank_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rest_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voted_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voted_ballot_unlisted {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.zero_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blank_ballot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rest_ballot)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.voted_ballot)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.voted_ballot_unlisted)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.zero_ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.signature);
        }
        if let Some(ref v) = self.blank_ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rest_ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.voted_ballot {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.voted_ballot_unlisted {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.zero_ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_bytes(1, &self.signature)?;
        }
        if let Some(ref v) = self.blank_ballot.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rest_ballot.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.voted_ballot {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.voted_ballot_unlisted {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.zero_ballot.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteStorage {
        VoteStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &VoteStorage| { &m.signature },
                |m: &mut VoteStorage| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "blank_ballot",
                |m: &VoteStorage| { &m.blank_ballot },
                |m: &mut VoteStorage| { &mut m.blank_ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "rest_ballot",
                |m: &VoteStorage| { &m.rest_ballot },
                |m: &mut VoteStorage| { &mut m.rest_ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CandidateBallot>>(
                "voted_ballot",
                |m: &VoteStorage| { &m.voted_ballot },
                |m: &mut VoteStorage| { &mut m.voted_ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CipherPointsToBallotPair>>(
                "voted_ballot_unlisted",
                |m: &VoteStorage| { &m.voted_ballot_unlisted },
                |m: &mut VoteStorage| { &mut m.voted_ballot_unlisted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "zero_ballot",
                |m: &VoteStorage| { &m.zero_ballot },
                |m: &mut VoteStorage| { &mut m.zero_ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteStorage>(
                "VoteStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteStorage {
        static instance: ::protobuf::rt::LazyV2<VoteStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteStorage::new)
    }
}

impl ::protobuf::Clear for VoteStorage {
    fn clear(&mut self) {
        self.signature.clear();
        self.blank_ballot.clear();
        self.rest_ballot.clear();
        self.voted_ballot.clear();
        self.voted_ballot_unlisted.clear();
        self.zero_ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CipherPointsToBallotPair {
    // message fields
    pub key: ::protobuf::SingularPtrField<CipherPoints>,
    pub ballot: ::protobuf::SingularPtrField<Ballot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CipherPointsToBallotPair {
    fn default() -> &'a CipherPointsToBallotPair {
        <CipherPointsToBallotPair as ::protobuf::Message>::default_instance()
    }
}

impl CipherPointsToBallotPair {
    pub fn new() -> CipherPointsToBallotPair {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.acv.proto.CipherPoints key = 1;


    pub fn get_key(&self) -> &CipherPoints {
        self.key.as_ref().unwrap_or_else(|| <CipherPoints as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: CipherPoints) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut CipherPoints {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> CipherPoints {
        self.key.take().unwrap_or_else(|| CipherPoints::new())
    }

    // .com.webank.wedpr.acv.proto.Ballot ballot = 3;


    pub fn get_ballot(&self) -> &Ballot {
        self.ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: Ballot) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut Ballot {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> Ballot {
        self.ballot.take().unwrap_or_else(|| Ballot::new())
    }
}

impl ::protobuf::Message for CipherPointsToBallotPair {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CipherPointsToBallotPair {
        CipherPointsToBallotPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CipherPoints>>(
                "key",
                |m: &CipherPointsToBallotPair| { &m.key },
                |m: &mut CipherPointsToBallotPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "ballot",
                |m: &CipherPointsToBallotPair| { &m.ballot },
                |m: &mut CipherPointsToBallotPair| { &mut m.ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CipherPointsToBallotPair>(
                "CipherPointsToBallotPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CipherPointsToBallotPair {
        static instance: ::protobuf::rt::LazyV2<CipherPointsToBallotPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CipherPointsToBallotPair::new)
    }
}

impl ::protobuf::Clear for CipherPointsToBallotPair {
    fn clear(&mut self) {
        self.key.clear();
        self.ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CipherPointsToBallotPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CipherPointsToBallotPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CipherPointsToBallotProofPair {
    // message fields
    pub key: ::protobuf::SingularPtrField<CipherPoints>,
    pub value: ::protobuf::SingularPtrField<BallotProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CipherPointsToBallotProofPair {
    fn default() -> &'a CipherPointsToBallotProofPair {
        <CipherPointsToBallotProofPair as ::protobuf::Message>::default_instance()
    }
}

impl CipherPointsToBallotProofPair {
    pub fn new() -> CipherPointsToBallotProofPair {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.acv.proto.CipherPoints key = 1;


    pub fn get_key(&self) -> &CipherPoints {
        self.key.as_ref().unwrap_or_else(|| <CipherPoints as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: CipherPoints) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut CipherPoints {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> CipherPoints {
        self.key.take().unwrap_or_else(|| CipherPoints::new())
    }

    // .com.webank.wedpr.acv.proto.BallotProof value = 2;


    pub fn get_value(&self) -> &BallotProof {
        self.value.as_ref().unwrap_or_else(|| <BallotProof as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: BallotProof) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut BallotProof {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> BallotProof {
        self.value.take().unwrap_or_else(|| BallotProof::new())
    }
}

impl ::protobuf::Message for CipherPointsToBallotProofPair {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CipherPointsToBallotProofPair {
        CipherPointsToBallotProofPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CipherPoints>>(
                "key",
                |m: &CipherPointsToBallotProofPair| { &m.key },
                |m: &mut CipherPointsToBallotProofPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BallotProof>>(
                "value",
                |m: &CipherPointsToBallotProofPair| { &m.value },
                |m: &mut CipherPointsToBallotProofPair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CipherPointsToBallotProofPair>(
                "CipherPointsToBallotProofPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CipherPointsToBallotProofPair {
        static instance: ::protobuf::rt::LazyV2<CipherPointsToBallotProofPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CipherPointsToBallotProofPair::new)
    }
}

impl ::protobuf::Clear for CipherPointsToBallotProofPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CipherPointsToBallotProofPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CipherPointsToBallotProofPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CipherPoints {
    // message fields
    pub ciphertext1: ::std::vec::Vec<u8>,
    pub ciphertext2: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CipherPoints {
    fn default() -> &'a CipherPoints {
        <CipherPoints as ::protobuf::Message>::default_instance()
    }
}

impl CipherPoints {
    pub fn new() -> CipherPoints {
        ::std::default::Default::default()
    }

    // bytes ciphertext1 = 1;


    pub fn get_ciphertext1(&self) -> &[u8] {
        &self.ciphertext1
    }
    pub fn clear_ciphertext1(&mut self) {
        self.ciphertext1.clear();
    }

    // Param is passed by value, moved
    pub fn set_ciphertext1(&mut self, v: ::std::vec::Vec<u8>) {
        self.ciphertext1 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ciphertext1(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ciphertext1
    }

    // Take field
    pub fn take_ciphertext1(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ciphertext1, ::std::vec::Vec::new())
    }

    // bytes ciphertext2 = 2;


    pub fn get_ciphertext2(&self) -> &[u8] {
        &self.ciphertext2
    }
    pub fn clear_ciphertext2(&mut self) {
        self.ciphertext2.clear();
    }

    // Param is passed by value, moved
    pub fn set_ciphertext2(&mut self, v: ::std::vec::Vec<u8>) {
        self.ciphertext2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ciphertext2(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ciphertext2
    }

    // Take field
    pub fn take_ciphertext2(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ciphertext2, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CipherPoints {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ciphertext1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ciphertext2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ciphertext1.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ciphertext1);
        }
        if !self.ciphertext2.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ciphertext2);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ciphertext1.is_empty() {
            os.write_bytes(1, &self.ciphertext1)?;
        }
        if !self.ciphertext2.is_empty() {
            os.write_bytes(2, &self.ciphertext2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CipherPoints {
        CipherPoints::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ciphertext1",
                |m: &CipherPoints| { &m.ciphertext1 },
                |m: &mut CipherPoints| { &mut m.ciphertext1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ciphertext2",
                |m: &CipherPoints| { &m.ciphertext2 },
                |m: &mut CipherPoints| { &mut m.ciphertext2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CipherPoints>(
                "CipherPoints",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CipherPoints {
        static instance: ::protobuf::rt::LazyV2<CipherPoints> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CipherPoints::new)
    }
}

impl ::protobuf::Clear for CipherPoints {
    fn clear(&mut self) {
        self.ciphertext1.clear();
        self.ciphertext2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CipherPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CipherPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CountingPart {
    // message fields
    pub counter_id: ::std::string::String,
    pub blinding_c2: ::std::vec::Vec<u8>,
    pub equality_proof: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CountingPart {
    fn default() -> &'a CountingPart {
        <CountingPart as ::protobuf::Message>::default_instance()
    }
}

impl CountingPart {
    pub fn new() -> CountingPart {
        ::std::default::Default::default()
    }

    // string counter_id = 1;


    pub fn get_counter_id(&self) -> &str {
        &self.counter_id
    }
    pub fn clear_counter_id(&mut self) {
        self.counter_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_id(&mut self, v: ::std::string::String) {
        self.counter_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_id(&mut self) -> &mut ::std::string::String {
        &mut self.counter_id
    }

    // Take field
    pub fn take_counter_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.counter_id, ::std::string::String::new())
    }

    // bytes blinding_c2 = 2;


    pub fn get_blinding_c2(&self) -> &[u8] {
        &self.blinding_c2
    }
    pub fn clear_blinding_c2(&mut self) {
        self.blinding_c2.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinding_c2(&mut self, v: ::std::vec::Vec<u8>) {
        self.blinding_c2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinding_c2(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blinding_c2
    }

    // Take field
    pub fn take_blinding_c2(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blinding_c2, ::std::vec::Vec::new())
    }

    // bytes equality_proof = 3;


    pub fn get_equality_proof(&self) -> &[u8] {
        &self.equality_proof
    }
    pub fn clear_equality_proof(&mut self) {
        self.equality_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_equality_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.equality_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_equality_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.equality_proof
    }

    // Take field
    pub fn take_equality_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.equality_proof, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CountingPart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.counter_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blinding_c2)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.equality_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.counter_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.counter_id);
        }
        if !self.blinding_c2.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.blinding_c2);
        }
        if !self.equality_proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.equality_proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.counter_id.is_empty() {
            os.write_string(1, &self.counter_id)?;
        }
        if !self.blinding_c2.is_empty() {
            os.write_bytes(2, &self.blinding_c2)?;
        }
        if !self.equality_proof.is_empty() {
            os.write_bytes(3, &self.equality_proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CountingPart {
        CountingPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "counter_id",
                |m: &CountingPart| { &m.counter_id },
                |m: &mut CountingPart| { &mut m.counter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blinding_c2",
                |m: &CountingPart| { &m.blinding_c2 },
                |m: &mut CountingPart| { &mut m.blinding_c2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "equality_proof",
                |m: &CountingPart| { &m.equality_proof },
                |m: &mut CountingPart| { &mut m.equality_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CountingPart>(
                "CountingPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CountingPart {
        static instance: ::protobuf::rt::LazyV2<CountingPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CountingPart::new)
    }
}

impl ::protobuf::Clear for CountingPart {
    fn clear(&mut self) {
        self.counter_id.clear();
        self.blinding_c2.clear();
        self.equality_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CountingPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountingPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringToCountingPartPair {
    // message fields
    pub key: ::std::string::String,
    pub value: ::protobuf::SingularPtrField<CountingPart>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringToCountingPartPair {
    fn default() -> &'a StringToCountingPartPair {
        <StringToCountingPartPair as ::protobuf::Message>::default_instance()
    }
}

impl StringToCountingPartPair {
    pub fn new() -> StringToCountingPartPair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // .com.webank.wedpr.acv.proto.CountingPart value = 2;


    pub fn get_value(&self) -> &CountingPart {
        self.value.as_ref().unwrap_or_else(|| <CountingPart as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CountingPart) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut CountingPart {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> CountingPart {
        self.value.take().unwrap_or_else(|| CountingPart::new())
    }
}

impl ::protobuf::Message for StringToCountingPartPair {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringToCountingPartPair {
        StringToCountingPartPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &StringToCountingPartPair| { &m.key },
                |m: &mut StringToCountingPartPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CountingPart>>(
                "value",
                |m: &StringToCountingPartPair| { &m.value },
                |m: &mut StringToCountingPartPair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringToCountingPartPair>(
                "StringToCountingPartPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringToCountingPartPair {
        static instance: ::protobuf::rt::LazyV2<StringToCountingPartPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringToCountingPartPair::new)
    }
}

impl ::protobuf::Clear for StringToCountingPartPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringToCountingPartPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringToCountingPartPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptedResultPartStorage {
    // message fields
    pub blank_part: ::protobuf::SingularPtrField<CountingPart>,
    pub candidate_part: ::protobuf::RepeatedField<StringToCountingPartPair>,
    pub unlisted_candidate_part: ::protobuf::RepeatedField<UnlistedBallotDecryptedResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptedResultPartStorage {
    fn default() -> &'a DecryptedResultPartStorage {
        <DecryptedResultPartStorage as ::protobuf::Message>::default_instance()
    }
}

impl DecryptedResultPartStorage {
    pub fn new() -> DecryptedResultPartStorage {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.acv.proto.CountingPart blank_part = 1;


    pub fn get_blank_part(&self) -> &CountingPart {
        self.blank_part.as_ref().unwrap_or_else(|| <CountingPart as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blank_part(&mut self) {
        self.blank_part.clear();
    }

    pub fn has_blank_part(&self) -> bool {
        self.blank_part.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blank_part(&mut self, v: CountingPart) {
        self.blank_part = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blank_part(&mut self) -> &mut CountingPart {
        if self.blank_part.is_none() {
            self.blank_part.set_default();
        }
        self.blank_part.as_mut().unwrap()
    }

    // Take field
    pub fn take_blank_part(&mut self) -> CountingPart {
        self.blank_part.take().unwrap_or_else(|| CountingPart::new())
    }

    // repeated .com.webank.wedpr.acv.proto.StringToCountingPartPair candidate_part = 2;


    pub fn get_candidate_part(&self) -> &[StringToCountingPartPair] {
        &self.candidate_part
    }
    pub fn clear_candidate_part(&mut self) {
        self.candidate_part.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate_part(&mut self, v: ::protobuf::RepeatedField<StringToCountingPartPair>) {
        self.candidate_part = v;
    }

    // Mutable pointer to the field.
    pub fn mut_candidate_part(&mut self) -> &mut ::protobuf::RepeatedField<StringToCountingPartPair> {
        &mut self.candidate_part
    }

    // Take field
    pub fn take_candidate_part(&mut self) -> ::protobuf::RepeatedField<StringToCountingPartPair> {
        ::std::mem::replace(&mut self.candidate_part, ::protobuf::RepeatedField::new())
    }

    // repeated .com.webank.wedpr.acv.proto.UnlistedBallotDecryptedResult unlisted_candidate_part = 3;


    pub fn get_unlisted_candidate_part(&self) -> &[UnlistedBallotDecryptedResult] {
        &self.unlisted_candidate_part
    }
    pub fn clear_unlisted_candidate_part(&mut self) {
        self.unlisted_candidate_part.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlisted_candidate_part(&mut self, v: ::protobuf::RepeatedField<UnlistedBallotDecryptedResult>) {
        self.unlisted_candidate_part = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlisted_candidate_part(&mut self) -> &mut ::protobuf::RepeatedField<UnlistedBallotDecryptedResult> {
        &mut self.unlisted_candidate_part
    }

    // Take field
    pub fn take_unlisted_candidate_part(&mut self) -> ::protobuf::RepeatedField<UnlistedBallotDecryptedResult> {
        ::std::mem::replace(&mut self.unlisted_candidate_part, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DecryptedResultPartStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.blank_part {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.candidate_part {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlisted_candidate_part {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blank_part)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.candidate_part)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlisted_candidate_part)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blank_part.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.candidate_part {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unlisted_candidate_part {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blank_part.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.candidate_part {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unlisted_candidate_part {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptedResultPartStorage {
        DecryptedResultPartStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CountingPart>>(
                "blank_part",
                |m: &DecryptedResultPartStorage| { &m.blank_part },
                |m: &mut DecryptedResultPartStorage| { &mut m.blank_part },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringToCountingPartPair>>(
                "candidate_part",
                |m: &DecryptedResultPartStorage| { &m.candidate_part },
                |m: &mut DecryptedResultPartStorage| { &mut m.candidate_part },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnlistedBallotDecryptedResult>>(
                "unlisted_candidate_part",
                |m: &DecryptedResultPartStorage| { &m.unlisted_candidate_part },
                |m: &mut DecryptedResultPartStorage| { &mut m.unlisted_candidate_part },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptedResultPartStorage>(
                "DecryptedResultPartStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptedResultPartStorage {
        static instance: ::protobuf::rt::LazyV2<DecryptedResultPartStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptedResultPartStorage::new)
    }
}

impl ::protobuf::Clear for DecryptedResultPartStorage {
    fn clear(&mut self) {
        self.blank_part.clear();
        self.candidate_part.clear();
        self.unlisted_candidate_part.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptedResultPartStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptedResultPartStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnlistedBallotDecryptedResult {
    // message fields
    pub candidate: i64,
    pub candidate_cipher: ::protobuf::SingularPtrField<CipherPoints>,
    pub decrypted_unlisted_candidate: ::protobuf::SingularPtrField<CountingPart>,
    pub decrypted_unlisted_candidate_ballot: ::protobuf::RepeatedField<CountingPart>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnlistedBallotDecryptedResult {
    fn default() -> &'a UnlistedBallotDecryptedResult {
        <UnlistedBallotDecryptedResult as ::protobuf::Message>::default_instance()
    }
}

impl UnlistedBallotDecryptedResult {
    pub fn new() -> UnlistedBallotDecryptedResult {
        ::std::default::Default::default()
    }

    // int64 candidate = 1;


    pub fn get_candidate(&self) -> i64 {
        self.candidate
    }
    pub fn clear_candidate(&mut self) {
        self.candidate = 0;
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: i64) {
        self.candidate = v;
    }

    // .com.webank.wedpr.acv.proto.CipherPoints candidate_cipher = 2;


    pub fn get_candidate_cipher(&self) -> &CipherPoints {
        self.candidate_cipher.as_ref().unwrap_or_else(|| <CipherPoints as ::protobuf::Message>::default_instance())
    }
    pub fn clear_candidate_cipher(&mut self) {
        self.candidate_cipher.clear();
    }

    pub fn has_candidate_cipher(&self) -> bool {
        self.candidate_cipher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate_cipher(&mut self, v: CipherPoints) {
        self.candidate_cipher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate_cipher(&mut self) -> &mut CipherPoints {
        if self.candidate_cipher.is_none() {
            self.candidate_cipher.set_default();
        }
        self.candidate_cipher.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate_cipher(&mut self) -> CipherPoints {
        self.candidate_cipher.take().unwrap_or_else(|| CipherPoints::new())
    }

    // .com.webank.wedpr.acv.proto.CountingPart decrypted_unlisted_candidate = 4;


    pub fn get_decrypted_unlisted_candidate(&self) -> &CountingPart {
        self.decrypted_unlisted_candidate.as_ref().unwrap_or_else(|| <CountingPart as ::protobuf::Message>::default_instance())
    }
    pub fn clear_decrypted_unlisted_candidate(&mut self) {
        self.decrypted_unlisted_candidate.clear();
    }

    pub fn has_decrypted_unlisted_candidate(&self) -> bool {
        self.decrypted_unlisted_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decrypted_unlisted_candidate(&mut self, v: CountingPart) {
        self.decrypted_unlisted_candidate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decrypted_unlisted_candidate(&mut self) -> &mut CountingPart {
        if self.decrypted_unlisted_candidate.is_none() {
            self.decrypted_unlisted_candidate.set_default();
        }
        self.decrypted_unlisted_candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_decrypted_unlisted_candidate(&mut self) -> CountingPart {
        self.decrypted_unlisted_candidate.take().unwrap_or_else(|| CountingPart::new())
    }

    // repeated .com.webank.wedpr.acv.proto.CountingPart decrypted_unlisted_candidate_ballot = 5;


    pub fn get_decrypted_unlisted_candidate_ballot(&self) -> &[CountingPart] {
        &self.decrypted_unlisted_candidate_ballot
    }
    pub fn clear_decrypted_unlisted_candidate_ballot(&mut self) {
        self.decrypted_unlisted_candidate_ballot.clear();
    }

    // Param is passed by value, moved
    pub fn set_decrypted_unlisted_candidate_ballot(&mut self, v: ::protobuf::RepeatedField<CountingPart>) {
        self.decrypted_unlisted_candidate_ballot = v;
    }

    // Mutable pointer to the field.
    pub fn mut_decrypted_unlisted_candidate_ballot(&mut self) -> &mut ::protobuf::RepeatedField<CountingPart> {
        &mut self.decrypted_unlisted_candidate_ballot
    }

    // Take field
    pub fn take_decrypted_unlisted_candidate_ballot(&mut self) -> ::protobuf::RepeatedField<CountingPart> {
        ::std::mem::replace(&mut self.decrypted_unlisted_candidate_ballot, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UnlistedBallotDecryptedResult {
    fn is_initialized(&self) -> bool {
        for v in &self.candidate_cipher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decrypted_unlisted_candidate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decrypted_unlisted_candidate_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.candidate = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.candidate_cipher)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.decrypted_unlisted_candidate)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.decrypted_unlisted_candidate_ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.candidate != 0 {
            my_size += ::protobuf::rt::value_size(1, self.candidate, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.candidate_cipher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.decrypted_unlisted_candidate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.decrypted_unlisted_candidate_ballot {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.candidate != 0 {
            os.write_int64(1, self.candidate)?;
        }
        if let Some(ref v) = self.candidate_cipher.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.decrypted_unlisted_candidate.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.decrypted_unlisted_candidate_ballot {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnlistedBallotDecryptedResult {
        UnlistedBallotDecryptedResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "candidate",
                |m: &UnlistedBallotDecryptedResult| { &m.candidate },
                |m: &mut UnlistedBallotDecryptedResult| { &mut m.candidate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CipherPoints>>(
                "candidate_cipher",
                |m: &UnlistedBallotDecryptedResult| { &m.candidate_cipher },
                |m: &mut UnlistedBallotDecryptedResult| { &mut m.candidate_cipher },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CountingPart>>(
                "decrypted_unlisted_candidate",
                |m: &UnlistedBallotDecryptedResult| { &m.decrypted_unlisted_candidate },
                |m: &mut UnlistedBallotDecryptedResult| { &mut m.decrypted_unlisted_candidate },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CountingPart>>(
                "decrypted_unlisted_candidate_ballot",
                |m: &UnlistedBallotDecryptedResult| { &m.decrypted_unlisted_candidate_ballot },
                |m: &mut UnlistedBallotDecryptedResult| { &mut m.decrypted_unlisted_candidate_ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnlistedBallotDecryptedResult>(
                "UnlistedBallotDecryptedResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnlistedBallotDecryptedResult {
        static instance: ::protobuf::rt::LazyV2<UnlistedBallotDecryptedResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnlistedBallotDecryptedResult::new)
    }
}

impl ::protobuf::Clear for UnlistedBallotDecryptedResult {
    fn clear(&mut self) {
        self.candidate = 0;
        self.candidate_cipher.clear();
        self.decrypted_unlisted_candidate.clear();
        self.decrypted_unlisted_candidate_ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlistedBallotDecryptedResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlistedBallotDecryptedResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteResultStorage {
    // message fields
    pub result: ::protobuf::RepeatedField<StringToInt64Pair>,
    pub unlisted_result: ::protobuf::RepeatedField<UnlistedVoteChoice>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteResultStorage {
    fn default() -> &'a VoteResultStorage {
        <VoteResultStorage as ::protobuf::Message>::default_instance()
    }
}

impl VoteResultStorage {
    pub fn new() -> VoteResultStorage {
        ::std::default::Default::default()
    }

    // repeated .com.webank.wedpr.acv.proto.StringToInt64Pair result = 1;


    pub fn get_result(&self) -> &[StringToInt64Pair] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::protobuf::RepeatedField<StringToInt64Pair>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result(&mut self) -> &mut ::protobuf::RepeatedField<StringToInt64Pair> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::protobuf::RepeatedField<StringToInt64Pair> {
        ::std::mem::replace(&mut self.result, ::protobuf::RepeatedField::new())
    }

    // repeated .com.webank.wedpr.acv.proto.UnlistedVoteChoice unlisted_result = 2;


    pub fn get_unlisted_result(&self) -> &[UnlistedVoteChoice] {
        &self.unlisted_result
    }
    pub fn clear_unlisted_result(&mut self) {
        self.unlisted_result.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlisted_result(&mut self, v: ::protobuf::RepeatedField<UnlistedVoteChoice>) {
        self.unlisted_result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlisted_result(&mut self) -> &mut ::protobuf::RepeatedField<UnlistedVoteChoice> {
        &mut self.unlisted_result
    }

    // Take field
    pub fn take_unlisted_result(&mut self) -> ::protobuf::RepeatedField<UnlistedVoteChoice> {
        ::std::mem::replace(&mut self.unlisted_result, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VoteResultStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlisted_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlisted_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unlisted_result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.result {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unlisted_result {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteResultStorage {
        VoteResultStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringToInt64Pair>>(
                "result",
                |m: &VoteResultStorage| { &m.result },
                |m: &mut VoteResultStorage| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnlistedVoteChoice>>(
                "unlisted_result",
                |m: &VoteResultStorage| { &m.unlisted_result },
                |m: &mut VoteResultStorage| { &mut m.unlisted_result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteResultStorage>(
                "VoteResultStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteResultStorage {
        static instance: ::protobuf::rt::LazyV2<VoteResultStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteResultStorage::new)
    }
}

impl ::protobuf::Clear for VoteResultStorage {
    fn clear(&mut self) {
        self.result.clear();
        self.unlisted_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteResultStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteResultStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringToInt64Pair {
    // message fields
    pub key: ::std::string::String,
    pub value: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringToInt64Pair {
    fn default() -> &'a StringToInt64Pair {
        <StringToInt64Pair as ::protobuf::Message>::default_instance()
    }
}

impl StringToInt64Pair {
    pub fn new() -> StringToInt64Pair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // int64 value = 2;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }
}

impl ::protobuf::Message for StringToInt64Pair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringToInt64Pair {
        StringToInt64Pair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &StringToInt64Pair| { &m.key },
                |m: &mut StringToInt64Pair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value",
                |m: &StringToInt64Pair| { &m.value },
                |m: &mut StringToInt64Pair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringToInt64Pair>(
                "StringToInt64Pair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringToInt64Pair {
        static instance: ::protobuf::rt::LazyV2<StringToInt64Pair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringToInt64Pair::new)
    }
}

impl ::protobuf::Clear for StringToInt64Pair {
    fn clear(&mut self) {
        self.key.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringToInt64Pair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringToInt64Pair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16solution/acv/acv.proto\x12\x1acom.webank.wedpr.acv.proto\"-\n\rCan\
    didateList\x12\x1c\n\tcandidate\x18\x01\x20\x03(\tR\tcandidate\"\x81\x01\
    \n\x15PollParametersStorage\x12\x1d\n\npoll_point\x18\x01\x20\x01(\x0cR\
    \tpollPoint\x12I\n\ncandidates\x18\x02\x20\x01(\x0b2).com.webank.wedpr.a\
    cv.proto.CandidateListR\ncandidates\";\n\rCounterSecret\x12*\n\x11poll_s\
    ecret_share\x18\x01\x20\x01(\x0cR\x0fpollSecretShare\"0\n\x0bVoterSecret\
    \x12!\n\x0cvoter_secret\x18\x01\x20\x01(\x0cR\x0bvoterSecret\"\xc5\x01\n\
    \x13RegistrationRequest\x12X\n\x0cweight_point\x18\x01\x20\x01(\x0b25.co\
    m.webank.wedpr.acv.proto.RegistrationBlindingPointR\x0bweightPoint\x12T\
    \n\nzero_point\x18\x02\x20\x01(\x0b25.com.webank.wedpr.acv.proto.Registr\
    ationBlindingPointR\tzeroPoint\"\x7f\n\x19RegistrationBlindingPoint\x12.\
    \n\x13blinding_poll_point\x18\x01\x20\x01(\x0cR\x11blindingPollPoint\x12\
    2\n\x15blinding_basepoint_g2\x18\x02\x20\x01(\x0cR\x13blindingBasepointG\
    2\"\xd8\x01\n\x14RegistrationResponse\x12!\n\x0cvoter_weight\x18\x01\x20\
    \x01(\rR\x0bvoterWeight\x12:\n\x06ballot\x18\x02\x20\x01(\x0b2\".com.web\
    ank.wedpr.acv.proto.BallotR\x06ballot\x12\x1c\n\tsignature\x18\x03\x20\
    \x01(\x0cR\tsignature\x12C\n\x0bzero_ballot\x18\x04\x20\x01(\x0b2\".com.\
    webank.wedpr.acv.proto.BallotR\nzeroBallot\"L\n\x06Ballot\x12\x20\n\x0bc\
    iphertext1\x18\x01\x20\x01(\x0cR\x0bciphertext1\x12\x20\n\x0bciphertext2\
    \x18\x02\x20\x01(\x0cR\x0bciphertext2\"h\n\x1dCounterParametersShareRequ\
    est\x12\x1d\n\ncounter_id\x18\x01\x20\x01(\tR\tcounterId\x12(\n\x10poll_\
    point_share\x18\x02\x20\x01(\x0cR\x0epollPointShare\"\x8f\x01\n\x18Count\
    erParametersStorage\x12s\n\x18counter_parameters_share\x18\x01\x20\x03(\
    \x0b29.com.webank.wedpr.acv.proto.CounterParametersShareRequestR\x16coun\
    terParametersShare\"@\n\nVoteChoice\x12\x1c\n\tcandidate\x18\x01\x20\x01\
    (\tR\tcandidate\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value\"M\n\x12\
    UnlistedVoteChoice\x12!\n\x0ccandidate_id\x18\x01\x20\x01(\rR\x0bcandida\
    teId\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value\"\xa6\x01\n\x0bVote\
    Choices\x12>\n\x06choice\x18\x01\x20\x03(\x0b2&.com.webank.wedpr.acv.pro\
    to.VoteChoiceR\x06choice\x12W\n\x0funlisted_choice\x18\x02\x20\x03(\x0b2\
    ..com.webank.wedpr.acv.proto.UnlistedVoteChoiceR\x0eunlistedChoice\"k\n\
    \x0fCandidateBallot\x12\x1c\n\tcandidate\x18\x01\x20\x01(\tR\tcandidate\
    \x12:\n\x06ballot\x18\x02\x20\x01(\x0b2\".com.webank.wedpr.acv.proto.Bal\
    lotR\x06ballot\"d\n\x0bBallotProof\x12!\n\x0cformat_proof\x18\x01\x20\
    \x01(\x0cR\x0bformatProof\x122\n\x15either_equality_proof\x18\x02\x20\
    \x01(\x0cR\x13eitherEqualityProof\"j\n\x17StringToBallotProofPair\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01\
    (\x0b2'.com.webank.wedpr.acv.proto.BallotProofR\x05value\"\xde\x02\n\x0b\
    VoteRequest\x12;\n\x04vote\x18\x01\x20\x01(\x0b2'.com.webank.wedpr.acv.p\
    roto.VoteStorageR\x04vote\x12V\n\x0cballot_proof\x18\x02\x20\x03(\x0b23.\
    com.webank.wedpr.acv.proto.StringToBallotProofPairR\x0bballotProof\x12\
    \x1f\n\x0brange_proof\x18\x03\x20\x01(\x0cR\nrangeProof\x12*\n\x11sum_ba\
    lance_proof\x18\x04\x20\x01(\x0cR\x0fsumBalanceProof\x12m\n\x15unlisted_\
    ballot_proof\x18\x05\x20\x03(\x0b29.com.webank.wedpr.acv.proto.CipherPoi\
    ntsToBallotProofPairR\x13unlistedBallotProof\"\xb6\x03\n\x0bVoteStorage\
    \x12\x1c\n\tsignature\x18\x01\x20\x01(\x0cR\tsignature\x12E\n\x0cblank_b\
    allot\x18\x02\x20\x01(\x0b2\".com.webank.wedpr.acv.proto.BallotR\x0bblan\
    kBallot\x12C\n\x0brest_ballot\x18\x03\x20\x01(\x0b2\".com.webank.wedpr.a\
    cv.proto.BallotR\nrestBallot\x12N\n\x0cvoted_ballot\x18\x04\x20\x03(\x0b\
    2+.com.webank.wedpr.acv.proto.CandidateBallotR\x0bvotedBallot\x12h\n\x15\
    voted_ballot_unlisted\x18\x06\x20\x03(\x0b24.com.webank.wedpr.acv.proto.\
    CipherPointsToBallotPairR\x13votedBallotUnlisted\x12C\n\x0bzero_ballot\
    \x18\x07\x20\x01(\x0b2\".com.webank.wedpr.acv.proto.BallotR\nzeroBallot\
    \"\x92\x01\n\x18CipherPointsToBallotPair\x12:\n\x03key\x18\x01\x20\x01(\
    \x0b2(.com.webank.wedpr.acv.proto.CipherPointsR\x03key\x12:\n\x06ballot\
    \x18\x03\x20\x01(\x0b2\".com.webank.wedpr.acv.proto.BallotR\x06ballot\"\
    \x9a\x01\n\x1dCipherPointsToBallotProofPair\x12:\n\x03key\x18\x01\x20\
    \x01(\x0b2(.com.webank.wedpr.acv.proto.CipherPointsR\x03key\x12=\n\x05va\
    lue\x18\x02\x20\x01(\x0b2'.com.webank.wedpr.acv.proto.BallotProofR\x05va\
    lue\"R\n\x0cCipherPoints\x12\x20\n\x0bciphertext1\x18\x01\x20\x01(\x0cR\
    \x0bciphertext1\x12\x20\n\x0bciphertext2\x18\x02\x20\x01(\x0cR\x0bcipher\
    text2\"u\n\x0cCountingPart\x12\x1d\n\ncounter_id\x18\x01\x20\x01(\tR\tco\
    unterId\x12\x1f\n\x0bblinding_c2\x18\x02\x20\x01(\x0cR\nblindingC2\x12%\
    \n\x0eequality_proof\x18\x03\x20\x01(\x0cR\requalityProof\"l\n\x18String\
    ToCountingPartPair\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12>\n\
    \x05value\x18\x02\x20\x01(\x0b2(.com.webank.wedpr.acv.proto.CountingPart\
    R\x05value\"\xb5\x02\n\x1aDecryptedResultPartStorage\x12G\n\nblank_part\
    \x18\x01\x20\x01(\x0b2(.com.webank.wedpr.acv.proto.CountingPartR\tblankP\
    art\x12[\n\x0ecandidate_part\x18\x02\x20\x03(\x0b24.com.webank.wedpr.acv\
    .proto.StringToCountingPartPairR\rcandidatePart\x12q\n\x17unlisted_candi\
    date_part\x18\x03\x20\x03(\x0b29.com.webank.wedpr.acv.proto.UnlistedBall\
    otDecryptedResultR\x15unlistedCandidatePart\"\xf7\x02\n\x1dUnlistedBallo\
    tDecryptedResult\x12\x1c\n\tcandidate\x18\x01\x20\x01(\x03R\tcandidate\
    \x12S\n\x10candidate_cipher\x18\x02\x20\x01(\x0b2(.com.webank.wedpr.acv.\
    proto.CipherPointsR\x0fcandidateCipher\x12j\n\x1cdecrypted_unlisted_cand\
    idate\x18\x04\x20\x01(\x0b2(.com.webank.wedpr.acv.proto.CountingPartR\
    \x1adecryptedUnlistedCandidate\x12w\n#decrypted_unlisted_candidate_ballo\
    t\x18\x05\x20\x03(\x0b2(.com.webank.wedpr.acv.proto.CountingPartR\x20dec\
    ryptedUnlistedCandidateBallot\"\xb3\x01\n\x11VoteResultStorage\x12E\n\
    \x06result\x18\x01\x20\x03(\x0b2-.com.webank.wedpr.acv.proto.StringToInt\
    64PairR\x06result\x12W\n\x0funlisted_result\x18\x02\x20\x03(\x0b2..com.w\
    ebank.wedpr.acv.proto.UnlistedVoteChoiceR\x0eunlistedResult\";\n\x11Stri\
    ngToInt64Pair\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\x03R\x05valueB\x1e\n\x1acom.webank.wedpr.acv.proto\
    P\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
