// Copyright 2020 WeDPR Lab Project Authors. Licensed under Apache-2.0.

// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `solution/acv/acv.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct CounterSecret {
    // message fields
    pub poll_secret_share: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterSecret {
    fn default() -> &'a CounterSecret {
        <CounterSecret as ::protobuf::Message>::default_instance()
    }
}

impl CounterSecret {
    pub fn new() -> CounterSecret {
        ::std::default::Default::default()
    }

    // bytes poll_secret_share = 1;


    pub fn get_poll_secret_share(&self) -> &[u8] {
        &self.poll_secret_share
    }
    pub fn clear_poll_secret_share(&mut self) {
        self.poll_secret_share.clear();
    }

    // Param is passed by value, moved
    pub fn set_poll_secret_share(&mut self, v: ::std::vec::Vec<u8>) {
        self.poll_secret_share = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poll_secret_share(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.poll_secret_share
    }

    // Take field
    pub fn take_poll_secret_share(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.poll_secret_share, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CounterSecret {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.poll_secret_share)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.poll_secret_share.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.poll_secret_share);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.poll_secret_share.is_empty() {
            os.write_bytes(1, &self.poll_secret_share)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterSecret {
        CounterSecret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "poll_secret_share",
                |m: &CounterSecret| { &m.poll_secret_share },
                |m: &mut CounterSecret| { &mut m.poll_secret_share },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterSecret>(
                "CounterSecret",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterSecret {
        static instance: ::protobuf::rt::LazyV2<CounterSecret> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterSecret::new)
    }
}

impl ::protobuf::Clear for CounterSecret {
    fn clear(&mut self) {
        self.poll_secret_share.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterSecret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterSecret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CounterSystemParametersShareRequest {
    // message fields
    pub counter_id: ::std::string::String,
    pub poll_point_share: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterSystemParametersShareRequest {
    fn default() -> &'a CounterSystemParametersShareRequest {
        <CounterSystemParametersShareRequest as ::protobuf::Message>::default_instance()
    }
}

impl CounterSystemParametersShareRequest {
    pub fn new() -> CounterSystemParametersShareRequest {
        ::std::default::Default::default()
    }

    // string counter_id = 1;


    pub fn get_counter_id(&self) -> &str {
        &self.counter_id
    }
    pub fn clear_counter_id(&mut self) {
        self.counter_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_id(&mut self, v: ::std::string::String) {
        self.counter_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_id(&mut self) -> &mut ::std::string::String {
        &mut self.counter_id
    }

    // Take field
    pub fn take_counter_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.counter_id, ::std::string::String::new())
    }

    // bytes poll_point_share = 2;


    pub fn get_poll_point_share(&self) -> &[u8] {
        &self.poll_point_share
    }
    pub fn clear_poll_point_share(&mut self) {
        self.poll_point_share.clear();
    }

    // Param is passed by value, moved
    pub fn set_poll_point_share(&mut self, v: ::std::vec::Vec<u8>) {
        self.poll_point_share = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poll_point_share(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.poll_point_share
    }

    // Take field
    pub fn take_poll_point_share(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.poll_point_share, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CounterSystemParametersShareRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.counter_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.poll_point_share)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.counter_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.counter_id);
        }
        if !self.poll_point_share.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.poll_point_share);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.counter_id.is_empty() {
            os.write_string(1, &self.counter_id)?;
        }
        if !self.poll_point_share.is_empty() {
            os.write_bytes(2, &self.poll_point_share)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterSystemParametersShareRequest {
        CounterSystemParametersShareRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "counter_id",
                |m: &CounterSystemParametersShareRequest| { &m.counter_id },
                |m: &mut CounterSystemParametersShareRequest| { &mut m.counter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "poll_point_share",
                |m: &CounterSystemParametersShareRequest| { &m.poll_point_share },
                |m: &mut CounterSystemParametersShareRequest| { &mut m.poll_point_share },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterSystemParametersShareRequest>(
                "CounterSystemParametersShareRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterSystemParametersShareRequest {
        static instance: ::protobuf::rt::LazyV2<CounterSystemParametersShareRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterSystemParametersShareRequest::new)
    }
}

impl ::protobuf::Clear for CounterSystemParametersShareRequest {
    fn clear(&mut self) {
        self.counter_id.clear();
        self.poll_point_share.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterSystemParametersShareRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterSystemParametersShareRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CounterSystemParametersStorage {
    // message fields
    pub counter_parameters_request: ::protobuf::RepeatedField<CounterSystemParametersShareRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterSystemParametersStorage {
    fn default() -> &'a CounterSystemParametersStorage {
        <CounterSystemParametersStorage as ::protobuf::Message>::default_instance()
    }
}

impl CounterSystemParametersStorage {
    pub fn new() -> CounterSystemParametersStorage {
        ::std::default::Default::default()
    }

    // repeated .com.webank.wedpr.acv.proto.CounterSystemParametersShareRequest counter_parameters_request = 1;


    pub fn get_counter_parameters_request(&self) -> &[CounterSystemParametersShareRequest] {
        &self.counter_parameters_request
    }
    pub fn clear_counter_parameters_request(&mut self) {
        self.counter_parameters_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_parameters_request(&mut self, v: ::protobuf::RepeatedField<CounterSystemParametersShareRequest>) {
        self.counter_parameters_request = v;
    }

    // Mutable pointer to the field.
    pub fn mut_counter_parameters_request(&mut self) -> &mut ::protobuf::RepeatedField<CounterSystemParametersShareRequest> {
        &mut self.counter_parameters_request
    }

    // Take field
    pub fn take_counter_parameters_request(&mut self) -> ::protobuf::RepeatedField<CounterSystemParametersShareRequest> {
        ::std::mem::replace(&mut self.counter_parameters_request, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CounterSystemParametersStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.counter_parameters_request {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.counter_parameters_request)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.counter_parameters_request {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.counter_parameters_request {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterSystemParametersStorage {
        CounterSystemParametersStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CounterSystemParametersShareRequest>>(
                "counter_parameters_request",
                |m: &CounterSystemParametersStorage| { &m.counter_parameters_request },
                |m: &mut CounterSystemParametersStorage| { &mut m.counter_parameters_request },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterSystemParametersStorage>(
                "CounterSystemParametersStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterSystemParametersStorage {
        static instance: ::protobuf::rt::LazyV2<CounterSystemParametersStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterSystemParametersStorage::new)
    }
}

impl ::protobuf::Clear for CounterSystemParametersStorage {
    fn clear(&mut self) {
        self.counter_parameters_request.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterSystemParametersStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterSystemParametersStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoterSecret {
    // message fields
    pub voter_secret: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoterSecret {
    fn default() -> &'a VoterSecret {
        <VoterSecret as ::protobuf::Message>::default_instance()
    }
}

impl VoterSecret {
    pub fn new() -> VoterSecret {
        ::std::default::Default::default()
    }

    // bytes voter_secret = 1;


    pub fn get_voter_secret(&self) -> &[u8] {
        &self.voter_secret
    }
    pub fn clear_voter_secret(&mut self) {
        self.voter_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_voter_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.voter_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voter_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.voter_secret
    }

    // Take field
    pub fn take_voter_secret(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.voter_secret, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VoterSecret {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.voter_secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.voter_secret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.voter_secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.voter_secret.is_empty() {
            os.write_bytes(1, &self.voter_secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoterSecret {
        VoterSecret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "voter_secret",
                |m: &VoterSecret| { &m.voter_secret },
                |m: &mut VoterSecret| { &mut m.voter_secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoterSecret>(
                "VoterSecret",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoterSecret {
        static instance: ::protobuf::rt::LazyV2<VoterSecret> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoterSecret::new)
    }
}

impl ::protobuf::Clear for VoterSecret {
    fn clear(&mut self) {
        self.voter_secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoterSecret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoterSecret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegistrationRequest {
    // message fields
    pub weight_point: ::protobuf::SingularPtrField<RegistrationBlindingPoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegistrationRequest {
    fn default() -> &'a RegistrationRequest {
        <RegistrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationRequest {
    pub fn new() -> RegistrationRequest {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.acv.proto.RegistrationBlindingPoint weight_point = 1;


    pub fn get_weight_point(&self) -> &RegistrationBlindingPoint {
        self.weight_point.as_ref().unwrap_or_else(|| <RegistrationBlindingPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_weight_point(&mut self) {
        self.weight_point.clear();
    }

    pub fn has_weight_point(&self) -> bool {
        self.weight_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight_point(&mut self, v: RegistrationBlindingPoint) {
        self.weight_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weight_point(&mut self) -> &mut RegistrationBlindingPoint {
        if self.weight_point.is_none() {
            self.weight_point.set_default();
        }
        self.weight_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_weight_point(&mut self) -> RegistrationBlindingPoint {
        self.weight_point.take().unwrap_or_else(|| RegistrationBlindingPoint::new())
    }
}

impl ::protobuf::Message for RegistrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.weight_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.weight_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.weight_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.weight_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegistrationRequest {
        RegistrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegistrationBlindingPoint>>(
                "weight_point",
                |m: &RegistrationRequest| { &m.weight_point },
                |m: &mut RegistrationRequest| { &mut m.weight_point },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegistrationRequest>(
                "RegistrationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegistrationRequest {
        static instance: ::protobuf::rt::LazyV2<RegistrationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegistrationRequest::new)
    }
}

impl ::protobuf::Clear for RegistrationRequest {
    fn clear(&mut self) {
        self.weight_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegistrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegistrationBlindingPoint {
    // message fields
    pub blinding_poll_point: ::std::vec::Vec<u8>,
    pub blinding_basepoint_g2: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegistrationBlindingPoint {
    fn default() -> &'a RegistrationBlindingPoint {
        <RegistrationBlindingPoint as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationBlindingPoint {
    pub fn new() -> RegistrationBlindingPoint {
        ::std::default::Default::default()
    }

    // bytes blinding_poll_point = 1;


    pub fn get_blinding_poll_point(&self) -> &[u8] {
        &self.blinding_poll_point
    }
    pub fn clear_blinding_poll_point(&mut self) {
        self.blinding_poll_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinding_poll_point(&mut self, v: ::std::vec::Vec<u8>) {
        self.blinding_poll_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinding_poll_point(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blinding_poll_point
    }

    // Take field
    pub fn take_blinding_poll_point(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blinding_poll_point, ::std::vec::Vec::new())
    }

    // bytes blinding_basepoint_g2 = 2;


    pub fn get_blinding_basepoint_g2(&self) -> &[u8] {
        &self.blinding_basepoint_g2
    }
    pub fn clear_blinding_basepoint_g2(&mut self) {
        self.blinding_basepoint_g2.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinding_basepoint_g2(&mut self, v: ::std::vec::Vec<u8>) {
        self.blinding_basepoint_g2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinding_basepoint_g2(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blinding_basepoint_g2
    }

    // Take field
    pub fn take_blinding_basepoint_g2(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blinding_basepoint_g2, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RegistrationBlindingPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blinding_poll_point)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blinding_basepoint_g2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blinding_poll_point.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.blinding_poll_point);
        }
        if !self.blinding_basepoint_g2.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.blinding_basepoint_g2);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.blinding_poll_point.is_empty() {
            os.write_bytes(1, &self.blinding_poll_point)?;
        }
        if !self.blinding_basepoint_g2.is_empty() {
            os.write_bytes(2, &self.blinding_basepoint_g2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegistrationBlindingPoint {
        RegistrationBlindingPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blinding_poll_point",
                |m: &RegistrationBlindingPoint| { &m.blinding_poll_point },
                |m: &mut RegistrationBlindingPoint| { &mut m.blinding_poll_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blinding_basepoint_g2",
                |m: &RegistrationBlindingPoint| { &m.blinding_basepoint_g2 },
                |m: &mut RegistrationBlindingPoint| { &mut m.blinding_basepoint_g2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegistrationBlindingPoint>(
                "RegistrationBlindingPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegistrationBlindingPoint {
        static instance: ::protobuf::rt::LazyV2<RegistrationBlindingPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegistrationBlindingPoint::new)
    }
}

impl ::protobuf::Clear for RegistrationBlindingPoint {
    fn clear(&mut self) {
        self.blinding_poll_point.clear();
        self.blinding_basepoint_g2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegistrationBlindingPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationBlindingPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegistrationResponse {
    // message fields
    pub voter_weight: u32,
    pub ballot: ::protobuf::SingularPtrField<Ballot>,
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegistrationResponse {
    fn default() -> &'a RegistrationResponse {
        <RegistrationResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationResponse {
    pub fn new() -> RegistrationResponse {
        ::std::default::Default::default()
    }

    // uint32 voter_weight = 1;


    pub fn get_voter_weight(&self) -> u32 {
        self.voter_weight
    }
    pub fn clear_voter_weight(&mut self) {
        self.voter_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_voter_weight(&mut self, v: u32) {
        self.voter_weight = v;
    }

    // .com.webank.wedpr.acv.proto.Ballot ballot = 2;


    pub fn get_ballot(&self) -> &Ballot {
        self.ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: Ballot) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut Ballot {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> Ballot {
        self.ballot.take().unwrap_or_else(|| Ballot::new())
    }

    // bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RegistrationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.voter_weight = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.voter_weight != 0 {
            my_size += ::protobuf::rt::value_size(1, self.voter_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.voter_weight != 0 {
            os.write_uint32(1, self.voter_weight)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegistrationResponse {
        RegistrationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "voter_weight",
                |m: &RegistrationResponse| { &m.voter_weight },
                |m: &mut RegistrationResponse| { &mut m.voter_weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "ballot",
                |m: &RegistrationResponse| { &m.ballot },
                |m: &mut RegistrationResponse| { &mut m.ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &RegistrationResponse| { &m.signature },
                |m: &mut RegistrationResponse| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegistrationResponse>(
                "RegistrationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegistrationResponse {
        static instance: ::protobuf::rt::LazyV2<RegistrationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegistrationResponse::new)
    }
}

impl ::protobuf::Clear for RegistrationResponse {
    fn clear(&mut self) {
        self.voter_weight = 0;
        self.ballot.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegistrationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ballot {
    // message fields
    pub ciphertext1: ::std::vec::Vec<u8>,
    pub ciphertext2: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ballot {
    fn default() -> &'a Ballot {
        <Ballot as ::protobuf::Message>::default_instance()
    }
}

impl Ballot {
    pub fn new() -> Ballot {
        ::std::default::Default::default()
    }

    // bytes ciphertext1 = 1;


    pub fn get_ciphertext1(&self) -> &[u8] {
        &self.ciphertext1
    }
    pub fn clear_ciphertext1(&mut self) {
        self.ciphertext1.clear();
    }

    // Param is passed by value, moved
    pub fn set_ciphertext1(&mut self, v: ::std::vec::Vec<u8>) {
        self.ciphertext1 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ciphertext1(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ciphertext1
    }

    // Take field
    pub fn take_ciphertext1(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ciphertext1, ::std::vec::Vec::new())
    }

    // bytes ciphertext2 = 2;


    pub fn get_ciphertext2(&self) -> &[u8] {
        &self.ciphertext2
    }
    pub fn clear_ciphertext2(&mut self) {
        self.ciphertext2.clear();
    }

    // Param is passed by value, moved
    pub fn set_ciphertext2(&mut self, v: ::std::vec::Vec<u8>) {
        self.ciphertext2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ciphertext2(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ciphertext2
    }

    // Take field
    pub fn take_ciphertext2(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ciphertext2, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Ballot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ciphertext1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ciphertext2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ciphertext1.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ciphertext1);
        }
        if !self.ciphertext2.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ciphertext2);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ciphertext1.is_empty() {
            os.write_bytes(1, &self.ciphertext1)?;
        }
        if !self.ciphertext2.is_empty() {
            os.write_bytes(2, &self.ciphertext2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ballot {
        Ballot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ciphertext1",
                |m: &Ballot| { &m.ciphertext1 },
                |m: &mut Ballot| { &mut m.ciphertext1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ciphertext2",
                |m: &Ballot| { &m.ciphertext2 },
                |m: &mut Ballot| { &mut m.ciphertext2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ballot>(
                "Ballot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ballot {
        static instance: ::protobuf::rt::LazyV2<Ballot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ballot::new)
    }
}

impl ::protobuf::Clear for Ballot {
    fn clear(&mut self) {
        self.ciphertext1.clear();
        self.ciphertext2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ballot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ballot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteChoice {
    // message fields
    pub candidate: ::std::string::String,
    pub value: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteChoice {
    fn default() -> &'a VoteChoice {
        <VoteChoice as ::protobuf::Message>::default_instance()
    }
}

impl VoteChoice {
    pub fn new() -> VoteChoice {
        ::std::default::Default::default()
    }

    // string candidate = 1;


    pub fn get_candidate(&self) -> &str {
        &self.candidate
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        &mut self.candidate
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.candidate, ::std::string::String::new())
    }

    // uint32 value = 2;


    pub fn get_value(&self) -> u32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }
}

impl ::protobuf::Message for VoteChoice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.candidate)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.candidate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.candidate);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.candidate.is_empty() {
            os.write_string(1, &self.candidate)?;
        }
        if self.value != 0 {
            os.write_uint32(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteChoice {
        VoteChoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "candidate",
                |m: &VoteChoice| { &m.candidate },
                |m: &mut VoteChoice| { &mut m.candidate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "value",
                |m: &VoteChoice| { &m.value },
                |m: &mut VoteChoice| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteChoice>(
                "VoteChoice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteChoice {
        static instance: ::protobuf::rt::LazyV2<VoteChoice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteChoice::new)
    }
}

impl ::protobuf::Clear for VoteChoice {
    fn clear(&mut self) {
        self.candidate.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteChoice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteChoices {
    // message fields
    pub choice: ::protobuf::RepeatedField<VoteChoice>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteChoices {
    fn default() -> &'a VoteChoices {
        <VoteChoices as ::protobuf::Message>::default_instance()
    }
}

impl VoteChoices {
    pub fn new() -> VoteChoices {
        ::std::default::Default::default()
    }

    // repeated .com.webank.wedpr.acv.proto.VoteChoice choice = 1;


    pub fn get_choice(&self) -> &[VoteChoice] {
        &self.choice
    }
    pub fn clear_choice(&mut self) {
        self.choice.clear();
    }

    // Param is passed by value, moved
    pub fn set_choice(&mut self, v: ::protobuf::RepeatedField<VoteChoice>) {
        self.choice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choice(&mut self) -> &mut ::protobuf::RepeatedField<VoteChoice> {
        &mut self.choice
    }

    // Take field
    pub fn take_choice(&mut self) -> ::protobuf::RepeatedField<VoteChoice> {
        ::std::mem::replace(&mut self.choice, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VoteChoices {
    fn is_initialized(&self) -> bool {
        for v in &self.choice {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.choice)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.choice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.choice {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteChoices {
        VoteChoices::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoteChoice>>(
                "choice",
                |m: &VoteChoices| { &m.choice },
                |m: &mut VoteChoices| { &mut m.choice },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteChoices>(
                "VoteChoices",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteChoices {
        static instance: ::protobuf::rt::LazyV2<VoteChoices> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteChoices::new)
    }
}

impl ::protobuf::Clear for VoteChoices {
    fn clear(&mut self) {
        self.choice.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteChoices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteChoices {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CandidateBallot {
    // message fields
    pub candidate: ::std::string::String,
    pub ballot: ::protobuf::SingularPtrField<Ballot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CandidateBallot {
    fn default() -> &'a CandidateBallot {
        <CandidateBallot as ::protobuf::Message>::default_instance()
    }
}

impl CandidateBallot {
    pub fn new() -> CandidateBallot {
        ::std::default::Default::default()
    }

    // string candidate = 1;


    pub fn get_candidate(&self) -> &str {
        &self.candidate
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        &mut self.candidate
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.candidate, ::std::string::String::new())
    }

    // .com.webank.wedpr.acv.proto.Ballot ballot = 2;


    pub fn get_ballot(&self) -> &Ballot {
        self.ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: Ballot) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut Ballot {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> Ballot {
        self.ballot.take().unwrap_or_else(|| Ballot::new())
    }
}

impl ::protobuf::Message for CandidateBallot {
    fn is_initialized(&self) -> bool {
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.candidate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.candidate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.candidate);
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.candidate.is_empty() {
            os.write_string(1, &self.candidate)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CandidateBallot {
        CandidateBallot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "candidate",
                |m: &CandidateBallot| { &m.candidate },
                |m: &mut CandidateBallot| { &mut m.candidate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "ballot",
                |m: &CandidateBallot| { &m.ballot },
                |m: &mut CandidateBallot| { &mut m.ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CandidateBallot>(
                "CandidateBallot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CandidateBallot {
        static instance: ::protobuf::rt::LazyV2<CandidateBallot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CandidateBallot::new)
    }
}

impl ::protobuf::Clear for CandidateBallot {
    fn clear(&mut self) {
        self.candidate.clear();
        self.ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CandidateBallot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CandidateBallot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteStorage {
    // message fields
    pub signature: ::std::vec::Vec<u8>,
    pub blank_ballot: ::protobuf::SingularPtrField<Ballot>,
    pub rest_ballot: ::protobuf::SingularPtrField<Ballot>,
    pub voted_ballot: ::protobuf::RepeatedField<CandidateBallot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteStorage {
    fn default() -> &'a VoteStorage {
        <VoteStorage as ::protobuf::Message>::default_instance()
    }
}

impl VoteStorage {
    pub fn new() -> VoteStorage {
        ::std::default::Default::default()
    }

    // bytes signature = 1;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // .com.webank.wedpr.acv.proto.Ballot blank_ballot = 2;


    pub fn get_blank_ballot(&self) -> &Ballot {
        self.blank_ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blank_ballot(&mut self) {
        self.blank_ballot.clear();
    }

    pub fn has_blank_ballot(&self) -> bool {
        self.blank_ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blank_ballot(&mut self, v: Ballot) {
        self.blank_ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blank_ballot(&mut self) -> &mut Ballot {
        if self.blank_ballot.is_none() {
            self.blank_ballot.set_default();
        }
        self.blank_ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_blank_ballot(&mut self) -> Ballot {
        self.blank_ballot.take().unwrap_or_else(|| Ballot::new())
    }

    // .com.webank.wedpr.acv.proto.Ballot rest_ballot = 3;


    pub fn get_rest_ballot(&self) -> &Ballot {
        self.rest_ballot.as_ref().unwrap_or_else(|| <Ballot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rest_ballot(&mut self) {
        self.rest_ballot.clear();
    }

    pub fn has_rest_ballot(&self) -> bool {
        self.rest_ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rest_ballot(&mut self, v: Ballot) {
        self.rest_ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rest_ballot(&mut self) -> &mut Ballot {
        if self.rest_ballot.is_none() {
            self.rest_ballot.set_default();
        }
        self.rest_ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_rest_ballot(&mut self) -> Ballot {
        self.rest_ballot.take().unwrap_or_else(|| Ballot::new())
    }

    // repeated .com.webank.wedpr.acv.proto.CandidateBallot voted_ballot = 4;


    pub fn get_voted_ballot(&self) -> &[CandidateBallot] {
        &self.voted_ballot
    }
    pub fn clear_voted_ballot(&mut self) {
        self.voted_ballot.clear();
    }

    // Param is passed by value, moved
    pub fn set_voted_ballot(&mut self, v: ::protobuf::RepeatedField<CandidateBallot>) {
        self.voted_ballot = v;
    }

    // Mutable pointer to the field.
    pub fn mut_voted_ballot(&mut self) -> &mut ::protobuf::RepeatedField<CandidateBallot> {
        &mut self.voted_ballot
    }

    // Take field
    pub fn take_voted_ballot(&mut self) -> ::protobuf::RepeatedField<CandidateBallot> {
        ::std::mem::replace(&mut self.voted_ballot, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VoteStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.blank_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rest_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voted_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blank_ballot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rest_ballot)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.voted_ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.signature);
        }
        if let Some(ref v) = self.blank_ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rest_ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.voted_ballot {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_bytes(1, &self.signature)?;
        }
        if let Some(ref v) = self.blank_ballot.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rest_ballot.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.voted_ballot {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteStorage {
        VoteStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &VoteStorage| { &m.signature },
                |m: &mut VoteStorage| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "blank_ballot",
                |m: &VoteStorage| { &m.blank_ballot },
                |m: &mut VoteStorage| { &mut m.blank_ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ballot>>(
                "rest_ballot",
                |m: &VoteStorage| { &m.rest_ballot },
                |m: &mut VoteStorage| { &mut m.rest_ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CandidateBallot>>(
                "voted_ballot",
                |m: &VoteStorage| { &m.voted_ballot },
                |m: &mut VoteStorage| { &mut m.voted_ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteStorage>(
                "VoteStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteStorage {
        static instance: ::protobuf::rt::LazyV2<VoteStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteStorage::new)
    }
}

impl ::protobuf::Clear for VoteStorage {
    fn clear(&mut self) {
        self.signature.clear();
        self.blank_ballot.clear();
        self.rest_ballot.clear();
        self.voted_ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CandidateList {
    // message fields
    pub candidate: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CandidateList {
    fn default() -> &'a CandidateList {
        <CandidateList as ::protobuf::Message>::default_instance()
    }
}

impl CandidateList {
    pub fn new() -> CandidateList {
        ::std::default::Default::default()
    }

    // repeated string candidate = 1;


    pub fn get_candidate(&self) -> &[::std::string::String] {
        &self.candidate
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.candidate = v;
    }

    // Mutable pointer to the field.
    pub fn mut_candidate(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.candidate
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.candidate, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CandidateList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.candidate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.candidate {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.candidate {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CandidateList {
        CandidateList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "candidate",
                |m: &CandidateList| { &m.candidate },
                |m: &mut CandidateList| { &mut m.candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CandidateList>(
                "CandidateList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CandidateList {
        static instance: ::protobuf::rt::LazyV2<CandidateList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CandidateList::new)
    }
}

impl ::protobuf::Clear for CandidateList {
    fn clear(&mut self) {
        self.candidate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CandidateList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CandidateList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SystemParametersStorage {
    // message fields
    pub poll_point: ::std::vec::Vec<u8>,
    pub candidates: ::protobuf::SingularPtrField<CandidateList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SystemParametersStorage {
    fn default() -> &'a SystemParametersStorage {
        <SystemParametersStorage as ::protobuf::Message>::default_instance()
    }
}

impl SystemParametersStorage {
    pub fn new() -> SystemParametersStorage {
        ::std::default::Default::default()
    }

    // bytes poll_point = 1;


    pub fn get_poll_point(&self) -> &[u8] {
        &self.poll_point
    }
    pub fn clear_poll_point(&mut self) {
        self.poll_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_poll_point(&mut self, v: ::std::vec::Vec<u8>) {
        self.poll_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poll_point(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.poll_point
    }

    // Take field
    pub fn take_poll_point(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.poll_point, ::std::vec::Vec::new())
    }

    // .com.webank.wedpr.acv.proto.CandidateList candidates = 2;


    pub fn get_candidates(&self) -> &CandidateList {
        self.candidates.as_ref().unwrap_or_else(|| <CandidateList as ::protobuf::Message>::default_instance())
    }
    pub fn clear_candidates(&mut self) {
        self.candidates.clear();
    }

    pub fn has_candidates(&self) -> bool {
        self.candidates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidates(&mut self, v: CandidateList) {
        self.candidates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidates(&mut self) -> &mut CandidateList {
        if self.candidates.is_none() {
            self.candidates.set_default();
        }
        self.candidates.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidates(&mut self) -> CandidateList {
        self.candidates.take().unwrap_or_else(|| CandidateList::new())
    }
}

impl ::protobuf::Message for SystemParametersStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.candidates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.poll_point)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.candidates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.poll_point.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.poll_point);
        }
        if let Some(ref v) = self.candidates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.poll_point.is_empty() {
            os.write_bytes(1, &self.poll_point)?;
        }
        if let Some(ref v) = self.candidates.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SystemParametersStorage {
        SystemParametersStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "poll_point",
                |m: &SystemParametersStorage| { &m.poll_point },
                |m: &mut SystemParametersStorage| { &mut m.poll_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CandidateList>>(
                "candidates",
                |m: &SystemParametersStorage| { &m.candidates },
                |m: &mut SystemParametersStorage| { &mut m.candidates },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SystemParametersStorage>(
                "SystemParametersStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SystemParametersStorage {
        static instance: ::protobuf::rt::LazyV2<SystemParametersStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SystemParametersStorage::new)
    }
}

impl ::protobuf::Clear for SystemParametersStorage {
    fn clear(&mut self) {
        self.poll_point.clear();
        self.candidates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SystemParametersStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemParametersStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BallotProof {
    // message fields
    pub format_proof: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BallotProof {
    fn default() -> &'a BallotProof {
        <BallotProof as ::protobuf::Message>::default_instance()
    }
}

impl BallotProof {
    pub fn new() -> BallotProof {
        ::std::default::Default::default()
    }

    // bytes format_proof = 1;


    pub fn get_format_proof(&self) -> &[u8] {
        &self.format_proof
    }
    pub fn clear_format_proof(&mut self) {
        self.format_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_format_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.format_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.format_proof
    }

    // Take field
    pub fn take_format_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.format_proof, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BallotProof {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.format_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.format_proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.format_proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.format_proof.is_empty() {
            os.write_bytes(1, &self.format_proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BallotProof {
        BallotProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "format_proof",
                |m: &BallotProof| { &m.format_proof },
                |m: &mut BallotProof| { &mut m.format_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BallotProof>(
                "BallotProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BallotProof {
        static instance: ::protobuf::rt::LazyV2<BallotProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BallotProof::new)
    }
}

impl ::protobuf::Clear for BallotProof {
    fn clear(&mut self) {
        self.format_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BallotProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BallotProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringToCandidateBallotProofPair {
    // message fields
    pub key: ::std::string::String,
    pub value: ::protobuf::SingularPtrField<BallotProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringToCandidateBallotProofPair {
    fn default() -> &'a StringToCandidateBallotProofPair {
        <StringToCandidateBallotProofPair as ::protobuf::Message>::default_instance()
    }
}

impl StringToCandidateBallotProofPair {
    pub fn new() -> StringToCandidateBallotProofPair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // .com.webank.wedpr.acv.proto.BallotProof value = 2;


    pub fn get_value(&self) -> &BallotProof {
        self.value.as_ref().unwrap_or_else(|| <BallotProof as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: BallotProof) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut BallotProof {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> BallotProof {
        self.value.take().unwrap_or_else(|| BallotProof::new())
    }
}

impl ::protobuf::Message for StringToCandidateBallotProofPair {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringToCandidateBallotProofPair {
        StringToCandidateBallotProofPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &StringToCandidateBallotProofPair| { &m.key },
                |m: &mut StringToCandidateBallotProofPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BallotProof>>(
                "value",
                |m: &StringToCandidateBallotProofPair| { &m.value },
                |m: &mut StringToCandidateBallotProofPair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringToCandidateBallotProofPair>(
                "StringToCandidateBallotProofPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringToCandidateBallotProofPair {
        static instance: ::protobuf::rt::LazyV2<StringToCandidateBallotProofPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringToCandidateBallotProofPair::new)
    }
}

impl ::protobuf::Clear for StringToCandidateBallotProofPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringToCandidateBallotProofPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringToCandidateBallotProofPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteRequest {
    // message fields
    pub vote: ::protobuf::SingularPtrField<VoteStorage>,
    pub ballot_proof: ::protobuf::RepeatedField<StringToCandidateBallotProofPair>,
    pub range_proof: ::std::vec::Vec<u8>,
    pub sum_balance_proof: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteRequest {
    fn default() -> &'a VoteRequest {
        <VoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl VoteRequest {
    pub fn new() -> VoteRequest {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.acv.proto.VoteStorage vote = 1;


    pub fn get_vote(&self) -> &VoteStorage {
        self.vote.as_ref().unwrap_or_else(|| <VoteStorage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vote(&mut self) {
        self.vote.clear();
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: VoteStorage) {
        self.vote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote(&mut self) -> &mut VoteStorage {
        if self.vote.is_none() {
            self.vote.set_default();
        }
        self.vote.as_mut().unwrap()
    }

    // Take field
    pub fn take_vote(&mut self) -> VoteStorage {
        self.vote.take().unwrap_or_else(|| VoteStorage::new())
    }

    // repeated .com.webank.wedpr.acv.proto.StringToCandidateBallotProofPair ballot_proof = 2;


    pub fn get_ballot_proof(&self) -> &[StringToCandidateBallotProofPair] {
        &self.ballot_proof
    }
    pub fn clear_ballot_proof(&mut self) {
        self.ballot_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_ballot_proof(&mut self, v: ::protobuf::RepeatedField<StringToCandidateBallotProofPair>) {
        self.ballot_proof = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ballot_proof(&mut self) -> &mut ::protobuf::RepeatedField<StringToCandidateBallotProofPair> {
        &mut self.ballot_proof
    }

    // Take field
    pub fn take_ballot_proof(&mut self) -> ::protobuf::RepeatedField<StringToCandidateBallotProofPair> {
        ::std::mem::replace(&mut self.ballot_proof, ::protobuf::RepeatedField::new())
    }

    // bytes range_proof = 3;


    pub fn get_range_proof(&self) -> &[u8] {
        &self.range_proof
    }
    pub fn clear_range_proof(&mut self) {
        self.range_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_proof
    }

    // Take field
    pub fn take_range_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_proof, ::std::vec::Vec::new())
    }

    // bytes sum_balance_proof = 4;


    pub fn get_sum_balance_proof(&self) -> &[u8] {
        &self.sum_balance_proof
    }
    pub fn clear_sum_balance_proof(&mut self) {
        self.sum_balance_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_sum_balance_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.sum_balance_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sum_balance_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sum_balance_proof
    }

    // Take field
    pub fn take_sum_balance_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sum_balance_proof, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VoteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.vote {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vote)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ballot_proof)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_proof)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sum_balance_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ballot_proof {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.range_proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.range_proof);
        }
        if !self.sum_balance_proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.sum_balance_proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vote.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ballot_proof {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.range_proof.is_empty() {
            os.write_bytes(3, &self.range_proof)?;
        }
        if !self.sum_balance_proof.is_empty() {
            os.write_bytes(4, &self.sum_balance_proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteRequest {
        VoteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoteStorage>>(
                "vote",
                |m: &VoteRequest| { &m.vote },
                |m: &mut VoteRequest| { &mut m.vote },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringToCandidateBallotProofPair>>(
                "ballot_proof",
                |m: &VoteRequest| { &m.ballot_proof },
                |m: &mut VoteRequest| { &mut m.ballot_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "range_proof",
                |m: &VoteRequest| { &m.range_proof },
                |m: &mut VoteRequest| { &mut m.range_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sum_balance_proof",
                |m: &VoteRequest| { &m.sum_balance_proof },
                |m: &mut VoteRequest| { &mut m.sum_balance_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteRequest>(
                "VoteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteRequest {
        static instance: ::protobuf::rt::LazyV2<VoteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteRequest::new)
    }
}

impl ::protobuf::Clear for VoteRequest {
    fn clear(&mut self) {
        self.vote.clear();
        self.ballot_proof.clear();
        self.range_proof.clear();
        self.sum_balance_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptedResultPartStorage {
    // message fields
    pub blank_part: ::protobuf::SingularPtrField<CountingPart>,
    pub candidate_part: ::protobuf::RepeatedField<StringToCountingPartPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptedResultPartStorage {
    fn default() -> &'a DecryptedResultPartStorage {
        <DecryptedResultPartStorage as ::protobuf::Message>::default_instance()
    }
}

impl DecryptedResultPartStorage {
    pub fn new() -> DecryptedResultPartStorage {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.acv.proto.CountingPart blank_part = 1;


    pub fn get_blank_part(&self) -> &CountingPart {
        self.blank_part.as_ref().unwrap_or_else(|| <CountingPart as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blank_part(&mut self) {
        self.blank_part.clear();
    }

    pub fn has_blank_part(&self) -> bool {
        self.blank_part.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blank_part(&mut self, v: CountingPart) {
        self.blank_part = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blank_part(&mut self) -> &mut CountingPart {
        if self.blank_part.is_none() {
            self.blank_part.set_default();
        }
        self.blank_part.as_mut().unwrap()
    }

    // Take field
    pub fn take_blank_part(&mut self) -> CountingPart {
        self.blank_part.take().unwrap_or_else(|| CountingPart::new())
    }

    // repeated .com.webank.wedpr.acv.proto.StringToCountingPartPair candidate_part = 2;


    pub fn get_candidate_part(&self) -> &[StringToCountingPartPair] {
        &self.candidate_part
    }
    pub fn clear_candidate_part(&mut self) {
        self.candidate_part.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate_part(&mut self, v: ::protobuf::RepeatedField<StringToCountingPartPair>) {
        self.candidate_part = v;
    }

    // Mutable pointer to the field.
    pub fn mut_candidate_part(&mut self) -> &mut ::protobuf::RepeatedField<StringToCountingPartPair> {
        &mut self.candidate_part
    }

    // Take field
    pub fn take_candidate_part(&mut self) -> ::protobuf::RepeatedField<StringToCountingPartPair> {
        ::std::mem::replace(&mut self.candidate_part, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DecryptedResultPartStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.blank_part {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.candidate_part {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blank_part)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.candidate_part)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blank_part.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.candidate_part {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blank_part.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.candidate_part {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptedResultPartStorage {
        DecryptedResultPartStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CountingPart>>(
                "blank_part",
                |m: &DecryptedResultPartStorage| { &m.blank_part },
                |m: &mut DecryptedResultPartStorage| { &mut m.blank_part },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringToCountingPartPair>>(
                "candidate_part",
                |m: &DecryptedResultPartStorage| { &m.candidate_part },
                |m: &mut DecryptedResultPartStorage| { &mut m.candidate_part },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptedResultPartStorage>(
                "DecryptedResultPartStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptedResultPartStorage {
        static instance: ::protobuf::rt::LazyV2<DecryptedResultPartStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptedResultPartStorage::new)
    }
}

impl ::protobuf::Clear for DecryptedResultPartStorage {
    fn clear(&mut self) {
        self.blank_part.clear();
        self.candidate_part.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptedResultPartStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptedResultPartStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringToCountingPartPair {
    // message fields
    pub key: ::std::string::String,
    pub value: ::protobuf::SingularPtrField<CountingPart>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringToCountingPartPair {
    fn default() -> &'a StringToCountingPartPair {
        <StringToCountingPartPair as ::protobuf::Message>::default_instance()
    }
}

impl StringToCountingPartPair {
    pub fn new() -> StringToCountingPartPair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // .com.webank.wedpr.acv.proto.CountingPart value = 2;


    pub fn get_value(&self) -> &CountingPart {
        self.value.as_ref().unwrap_or_else(|| <CountingPart as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CountingPart) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut CountingPart {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> CountingPart {
        self.value.take().unwrap_or_else(|| CountingPart::new())
    }
}

impl ::protobuf::Message for StringToCountingPartPair {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringToCountingPartPair {
        StringToCountingPartPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &StringToCountingPartPair| { &m.key },
                |m: &mut StringToCountingPartPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CountingPart>>(
                "value",
                |m: &StringToCountingPartPair| { &m.value },
                |m: &mut StringToCountingPartPair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringToCountingPartPair>(
                "StringToCountingPartPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringToCountingPartPair {
        static instance: ::protobuf::rt::LazyV2<StringToCountingPartPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringToCountingPartPair::new)
    }
}

impl ::protobuf::Clear for StringToCountingPartPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringToCountingPartPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringToCountingPartPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CountingPart {
    // message fields
    pub counter_id: ::std::string::String,
    pub blinding_c2: ::std::vec::Vec<u8>,
    pub equality_proof: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CountingPart {
    fn default() -> &'a CountingPart {
        <CountingPart as ::protobuf::Message>::default_instance()
    }
}

impl CountingPart {
    pub fn new() -> CountingPart {
        ::std::default::Default::default()
    }

    // string counter_id = 1;


    pub fn get_counter_id(&self) -> &str {
        &self.counter_id
    }
    pub fn clear_counter_id(&mut self) {
        self.counter_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_counter_id(&mut self, v: ::std::string::String) {
        self.counter_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_id(&mut self) -> &mut ::std::string::String {
        &mut self.counter_id
    }

    // Take field
    pub fn take_counter_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.counter_id, ::std::string::String::new())
    }

    // bytes blinding_c2 = 2;


    pub fn get_blinding_c2(&self) -> &[u8] {
        &self.blinding_c2
    }
    pub fn clear_blinding_c2(&mut self) {
        self.blinding_c2.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinding_c2(&mut self, v: ::std::vec::Vec<u8>) {
        self.blinding_c2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinding_c2(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blinding_c2
    }

    // Take field
    pub fn take_blinding_c2(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blinding_c2, ::std::vec::Vec::new())
    }

    // bytes equality_proof = 3;


    pub fn get_equality_proof(&self) -> &[u8] {
        &self.equality_proof
    }
    pub fn clear_equality_proof(&mut self) {
        self.equality_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_equality_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.equality_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_equality_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.equality_proof
    }

    // Take field
    pub fn take_equality_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.equality_proof, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CountingPart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.counter_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blinding_c2)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.equality_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.counter_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.counter_id);
        }
        if !self.blinding_c2.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.blinding_c2);
        }
        if !self.equality_proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.equality_proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.counter_id.is_empty() {
            os.write_string(1, &self.counter_id)?;
        }
        if !self.blinding_c2.is_empty() {
            os.write_bytes(2, &self.blinding_c2)?;
        }
        if !self.equality_proof.is_empty() {
            os.write_bytes(3, &self.equality_proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CountingPart {
        CountingPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "counter_id",
                |m: &CountingPart| { &m.counter_id },
                |m: &mut CountingPart| { &mut m.counter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blinding_c2",
                |m: &CountingPart| { &m.blinding_c2 },
                |m: &mut CountingPart| { &mut m.blinding_c2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "equality_proof",
                |m: &CountingPart| { &m.equality_proof },
                |m: &mut CountingPart| { &mut m.equality_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CountingPart>(
                "CountingPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CountingPart {
        static instance: ::protobuf::rt::LazyV2<CountingPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CountingPart::new)
    }
}

impl ::protobuf::Clear for CountingPart {
    fn clear(&mut self) {
        self.counter_id.clear();
        self.blinding_c2.clear();
        self.equality_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CountingPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountingPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteResultStorage {
    // message fields
    pub result: ::protobuf::RepeatedField<StringToInt64Pair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteResultStorage {
    fn default() -> &'a VoteResultStorage {
        <VoteResultStorage as ::protobuf::Message>::default_instance()
    }
}

impl VoteResultStorage {
    pub fn new() -> VoteResultStorage {
        ::std::default::Default::default()
    }

    // repeated .com.webank.wedpr.acv.proto.StringToInt64Pair result = 1;


    pub fn get_result(&self) -> &[StringToInt64Pair] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::protobuf::RepeatedField<StringToInt64Pair>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result(&mut self) -> &mut ::protobuf::RepeatedField<StringToInt64Pair> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::protobuf::RepeatedField<StringToInt64Pair> {
        ::std::mem::replace(&mut self.result, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VoteResultStorage {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.result {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteResultStorage {
        VoteResultStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringToInt64Pair>>(
                "result",
                |m: &VoteResultStorage| { &m.result },
                |m: &mut VoteResultStorage| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteResultStorage>(
                "VoteResultStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteResultStorage {
        static instance: ::protobuf::rt::LazyV2<VoteResultStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteResultStorage::new)
    }
}

impl ::protobuf::Clear for VoteResultStorage {
    fn clear(&mut self) {
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteResultStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteResultStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringToInt64Pair {
    // message fields
    pub key: ::std::string::String,
    pub value: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringToInt64Pair {
    fn default() -> &'a StringToInt64Pair {
        <StringToInt64Pair as ::protobuf::Message>::default_instance()
    }
}

impl StringToInt64Pair {
    pub fn new() -> StringToInt64Pair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // int64 value = 2;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }
}

impl ::protobuf::Message for StringToInt64Pair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringToInt64Pair {
        StringToInt64Pair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &StringToInt64Pair| { &m.key },
                |m: &mut StringToInt64Pair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value",
                |m: &StringToInt64Pair| { &m.value },
                |m: &mut StringToInt64Pair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringToInt64Pair>(
                "StringToInt64Pair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringToInt64Pair {
        static instance: ::protobuf::rt::LazyV2<StringToInt64Pair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringToInt64Pair::new)
    }
}

impl ::protobuf::Clear for StringToInt64Pair {
    fn clear(&mut self) {
        self.key.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringToInt64Pair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringToInt64Pair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16solution/acv/acv.proto\x12\x1acom.webank.wedpr.acv.proto\";\n\rCou\
    nterSecret\x12*\n\x11poll_secret_share\x18\x01\x20\x01(\x0cR\x0fpollSecr\
    etShare\"n\n#CounterSystemParametersShareRequest\x12\x1d\n\ncounter_id\
    \x18\x01\x20\x01(\tR\tcounterId\x12(\n\x10poll_point_share\x18\x02\x20\
    \x01(\x0cR\x0epollPointShare\"\x9f\x01\n\x1eCounterSystemParametersStora\
    ge\x12}\n\x1acounter_parameters_request\x18\x01\x20\x03(\x0b2?.com.weban\
    k.wedpr.acv.proto.CounterSystemParametersShareRequestR\x18counterParamet\
    ersRequest\"0\n\x0bVoterSecret\x12!\n\x0cvoter_secret\x18\x01\x20\x01(\
    \x0cR\x0bvoterSecret\"o\n\x13RegistrationRequest\x12X\n\x0cweight_point\
    \x18\x01\x20\x01(\x0b25.com.webank.wedpr.acv.proto.RegistrationBlindingP\
    ointR\x0bweightPoint\"\x7f\n\x19RegistrationBlindingPoint\x12.\n\x13blin\
    ding_poll_point\x18\x01\x20\x01(\x0cR\x11blindingPollPoint\x122\n\x15bli\
    nding_basepoint_g2\x18\x02\x20\x01(\x0cR\x13blindingBasepointG2\"\x93\
    \x01\n\x14RegistrationResponse\x12!\n\x0cvoter_weight\x18\x01\x20\x01(\r\
    R\x0bvoterWeight\x12:\n\x06ballot\x18\x02\x20\x01(\x0b2\".com.webank.wed\
    pr.acv.proto.BallotR\x06ballot\x12\x1c\n\tsignature\x18\x03\x20\x01(\x0c\
    R\tsignature\"L\n\x06Ballot\x12\x20\n\x0bciphertext1\x18\x01\x20\x01(\
    \x0cR\x0bciphertext1\x12\x20\n\x0bciphertext2\x18\x02\x20\x01(\x0cR\x0bc\
    iphertext2\"@\n\nVoteChoice\x12\x1c\n\tcandidate\x18\x01\x20\x01(\tR\tca\
    ndidate\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value\"M\n\x0bVoteChoi\
    ces\x12>\n\x06choice\x18\x01\x20\x03(\x0b2&.com.webank.wedpr.acv.proto.V\
    oteChoiceR\x06choice\"k\n\x0fCandidateBallot\x12\x1c\n\tcandidate\x18\
    \x01\x20\x01(\tR\tcandidate\x12:\n\x06ballot\x18\x02\x20\x01(\x0b2\".com\
    .webank.wedpr.acv.proto.BallotR\x06ballot\"\x87\x02\n\x0bVoteStorage\x12\
    \x1c\n\tsignature\x18\x01\x20\x01(\x0cR\tsignature\x12E\n\x0cblank_ballo\
    t\x18\x02\x20\x01(\x0b2\".com.webank.wedpr.acv.proto.BallotR\x0bblankBal\
    lot\x12C\n\x0brest_ballot\x18\x03\x20\x01(\x0b2\".com.webank.wedpr.acv.p\
    roto.BallotR\nrestBallot\x12N\n\x0cvoted_ballot\x18\x04\x20\x03(\x0b2+.c\
    om.webank.wedpr.acv.proto.CandidateBallotR\x0bvotedBallot\"-\n\rCandidat\
    eList\x12\x1c\n\tcandidate\x18\x01\x20\x03(\tR\tcandidate\"\x83\x01\n\
    \x17SystemParametersStorage\x12\x1d\n\npoll_point\x18\x01\x20\x01(\x0cR\
    \tpollPoint\x12I\n\ncandidates\x18\x02\x20\x01(\x0b2).com.webank.wedpr.a\
    cv.proto.CandidateListR\ncandidates\"0\n\x0bBallotProof\x12!\n\x0cformat\
    _proof\x18\x01\x20\x01(\x0cR\x0bformatProof\"s\n\x20StringToCandidateBal\
    lotProofPair\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\
    \x18\x02\x20\x01(\x0b2'.com.webank.wedpr.acv.proto.BallotProofR\x05value\
    \"\xf8\x01\n\x0bVoteRequest\x12;\n\x04vote\x18\x01\x20\x01(\x0b2'.com.we\
    bank.wedpr.acv.proto.VoteStorageR\x04vote\x12_\n\x0cballot_proof\x18\x02\
    \x20\x03(\x0b2<.com.webank.wedpr.acv.proto.StringToCandidateBallotProofP\
    airR\x0bballotProof\x12\x1f\n\x0brange_proof\x18\x03\x20\x01(\x0cR\nrang\
    eProof\x12*\n\x11sum_balance_proof\x18\x04\x20\x01(\x0cR\x0fsumBalancePr\
    oof\"\xc2\x01\n\x1aDecryptedResultPartStorage\x12G\n\nblank_part\x18\x01\
    \x20\x01(\x0b2(.com.webank.wedpr.acv.proto.CountingPartR\tblankPart\x12[\
    \n\x0ecandidate_part\x18\x02\x20\x03(\x0b24.com.webank.wedpr.acv.proto.S\
    tringToCountingPartPairR\rcandidatePart\"l\n\x18StringToCountingPartPair\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12>\n\x05value\x18\x02\x20\
    \x01(\x0b2(.com.webank.wedpr.acv.proto.CountingPartR\x05value\"u\n\x0cCo\
    untingPart\x12\x1d\n\ncounter_id\x18\x01\x20\x01(\tR\tcounterId\x12\x1f\
    \n\x0bblinding_c2\x18\x02\x20\x01(\x0cR\nblindingC2\x12%\n\x0eequality_p\
    roof\x18\x03\x20\x01(\x0cR\requalityProof\"Z\n\x11VoteResultStorage\x12E\
    \n\x06result\x18\x01\x20\x03(\x0b2-.com.webank.wedpr.acv.proto.StringToI\
    nt64PairR\x06result\";\n\x11StringToInt64Pair\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05valueB\
    \x1e\n\x1acom.webank.wedpr.acv.protoP\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
