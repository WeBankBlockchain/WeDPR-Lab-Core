// This file is generated by rust-protobuf 2.22.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `solution/scd/scd.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_1;

#[derive(PartialEq,Clone,Default)]
pub struct CertificateSchema {
    // message fields
    pub attribute_name: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CertificateSchema {
    fn default() -> &'a CertificateSchema {
        <CertificateSchema as ::protobuf::Message>::default_instance()
    }
}

impl CertificateSchema {
    pub fn new() -> CertificateSchema {
        ::std::default::Default::default()
    }

    // repeated string attribute_name = 1;


    pub fn get_attribute_name(&self) -> &[::std::string::String] {
        &self.attribute_name
    }
    pub fn clear_attribute_name(&mut self) {
        self.attribute_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.attribute_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.attribute_name
    }

    // Take field
    pub fn take_attribute_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.attribute_name, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CertificateSchema {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.attribute_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attribute_name {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.attribute_name {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CertificateSchema {
        CertificateSchema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attribute_name",
                |m: &CertificateSchema| { &m.attribute_name },
                |m: &mut CertificateSchema| { &mut m.attribute_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CertificateSchema>(
                "CertificateSchema",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CertificateSchema {
        static instance: ::protobuf::rt::LazyV2<CertificateSchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CertificateSchema::new)
    }
}

impl ::protobuf::Clear for CertificateSchema {
    fn clear(&mut self) {
        self.attribute_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CertificateSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CertificateSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringToStringPair {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringToStringPair {
    fn default() -> &'a StringToStringPair {
        <StringToStringPair as ::protobuf::Message>::default_instance()
    }
}

impl StringToStringPair {
    pub fn new() -> StringToStringPair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StringToStringPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringToStringPair {
        StringToStringPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &StringToStringPair| { &m.key },
                |m: &mut StringToStringPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &StringToStringPair| { &m.value },
                |m: &mut StringToStringPair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringToStringPair>(
                "StringToStringPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringToStringPair {
        static instance: ::protobuf::rt::LazyV2<StringToStringPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringToStringPair::new)
    }
}

impl ::protobuf::Clear for StringToStringPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringToStringPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringToStringPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CertificateTemplate {
    // message fields
    pub certificate_schema: ::protobuf::SingularPtrField<CertificateSchema>,
    pub template_correctness_proof: ::std::string::String,
    pub template_public_key: ::protobuf::SingularPtrField<TemplatePublicKey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CertificateTemplate {
    fn default() -> &'a CertificateTemplate {
        <CertificateTemplate as ::protobuf::Message>::default_instance()
    }
}

impl CertificateTemplate {
    pub fn new() -> CertificateTemplate {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.scd.proto.CertificateSchema certificate_schema = 1;


    pub fn get_certificate_schema(&self) -> &CertificateSchema {
        self.certificate_schema.as_ref().unwrap_or_else(|| <CertificateSchema as ::protobuf::Message>::default_instance())
    }
    pub fn clear_certificate_schema(&mut self) {
        self.certificate_schema.clear();
    }

    pub fn has_certificate_schema(&self) -> bool {
        self.certificate_schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certificate_schema(&mut self, v: CertificateSchema) {
        self.certificate_schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certificate_schema(&mut self) -> &mut CertificateSchema {
        if self.certificate_schema.is_none() {
            self.certificate_schema.set_default();
        }
        self.certificate_schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_certificate_schema(&mut self) -> CertificateSchema {
        self.certificate_schema.take().unwrap_or_else(|| CertificateSchema::new())
    }

    // string template_correctness_proof = 2;


    pub fn get_template_correctness_proof(&self) -> &str {
        &self.template_correctness_proof
    }
    pub fn clear_template_correctness_proof(&mut self) {
        self.template_correctness_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_template_correctness_proof(&mut self, v: ::std::string::String) {
        self.template_correctness_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_correctness_proof(&mut self) -> &mut ::std::string::String {
        &mut self.template_correctness_proof
    }

    // Take field
    pub fn take_template_correctness_proof(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.template_correctness_proof, ::std::string::String::new())
    }

    // .com.webank.wedpr.scd.proto.TemplatePublicKey template_public_key = 3;


    pub fn get_template_public_key(&self) -> &TemplatePublicKey {
        self.template_public_key.as_ref().unwrap_or_else(|| <TemplatePublicKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_template_public_key(&mut self) {
        self.template_public_key.clear();
    }

    pub fn has_template_public_key(&self) -> bool {
        self.template_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_public_key(&mut self, v: TemplatePublicKey) {
        self.template_public_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_public_key(&mut self) -> &mut TemplatePublicKey {
        if self.template_public_key.is_none() {
            self.template_public_key.set_default();
        }
        self.template_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_public_key(&mut self) -> TemplatePublicKey {
        self.template_public_key.take().unwrap_or_else(|| TemplatePublicKey::new())
    }
}

impl ::protobuf::Message for CertificateTemplate {
    fn is_initialized(&self) -> bool {
        for v in &self.certificate_schema {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.template_public_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.certificate_schema)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.template_correctness_proof)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template_public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.certificate_schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.template_correctness_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.template_correctness_proof);
        }
        if let Some(ref v) = self.template_public_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.certificate_schema.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.template_correctness_proof.is_empty() {
            os.write_string(2, &self.template_correctness_proof)?;
        }
        if let Some(ref v) = self.template_public_key.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CertificateTemplate {
        CertificateTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CertificateSchema>>(
                "certificate_schema",
                |m: &CertificateTemplate| { &m.certificate_schema },
                |m: &mut CertificateTemplate| { &mut m.certificate_schema },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "template_correctness_proof",
                |m: &CertificateTemplate| { &m.template_correctness_proof },
                |m: &mut CertificateTemplate| { &mut m.template_correctness_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TemplatePublicKey>>(
                "template_public_key",
                |m: &CertificateTemplate| { &m.template_public_key },
                |m: &mut CertificateTemplate| { &mut m.template_public_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CertificateTemplate>(
                "CertificateTemplate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CertificateTemplate {
        static instance: ::protobuf::rt::LazyV2<CertificateTemplate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CertificateTemplate::new)
    }
}

impl ::protobuf::Clear for CertificateTemplate {
    fn clear(&mut self) {
        self.certificate_schema.clear();
        self.template_correctness_proof.clear();
        self.template_public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CertificateTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CertificateTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TemplatePublicKey {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TemplatePublicKey {
    fn default() -> &'a TemplatePublicKey {
        <TemplatePublicKey as ::protobuf::Message>::default_instance()
    }
}

impl TemplatePublicKey {
    pub fn new() -> TemplatePublicKey {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TemplatePublicKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TemplatePublicKey {
        TemplatePublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &TemplatePublicKey| { &m.key },
                |m: &mut TemplatePublicKey| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TemplatePublicKey>(
                "TemplatePublicKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TemplatePublicKey {
        static instance: ::protobuf::rt::LazyV2<TemplatePublicKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TemplatePublicKey::new)
    }
}

impl ::protobuf::Clear for TemplatePublicKey {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TemplatePublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplatePublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TemplatePrivateKey {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TemplatePrivateKey {
    fn default() -> &'a TemplatePrivateKey {
        <TemplatePrivateKey as ::protobuf::Message>::default_instance()
    }
}

impl TemplatePrivateKey {
    pub fn new() -> TemplatePrivateKey {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TemplatePrivateKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TemplatePrivateKey {
        TemplatePrivateKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &TemplatePrivateKey| { &m.key },
                |m: &mut TemplatePrivateKey| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TemplatePrivateKey>(
                "TemplatePrivateKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TemplatePrivateKey {
        static instance: ::protobuf::rt::LazyV2<TemplatePrivateKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TemplatePrivateKey::new)
    }
}

impl ::protobuf::Clear for TemplatePrivateKey {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TemplatePrivateKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplatePrivateKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeDict {
    // message fields
    pub pair: ::protobuf::RepeatedField<StringToStringPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeDict {
    fn default() -> &'a AttributeDict {
        <AttributeDict as ::protobuf::Message>::default_instance()
    }
}

impl AttributeDict {
    pub fn new() -> AttributeDict {
        ::std::default::Default::default()
    }

    // repeated .com.webank.wedpr.scd.proto.StringToStringPair pair = 1;


    pub fn get_pair(&self) -> &[StringToStringPair] {
        &self.pair
    }
    pub fn clear_pair(&mut self) {
        self.pair.clear();
    }

    // Param is passed by value, moved
    pub fn set_pair(&mut self, v: ::protobuf::RepeatedField<StringToStringPair>) {
        self.pair = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pair(&mut self) -> &mut ::protobuf::RepeatedField<StringToStringPair> {
        &mut self.pair
    }

    // Take field
    pub fn take_pair(&mut self) -> ::protobuf::RepeatedField<StringToStringPair> {
        ::std::mem::replace(&mut self.pair, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AttributeDict {
    fn is_initialized(&self) -> bool {
        for v in &self.pair {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pair)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pair {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pair {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeDict {
        AttributeDict::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringToStringPair>>(
                "pair",
                |m: &AttributeDict| { &m.pair },
                |m: &mut AttributeDict| { &mut m.pair },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AttributeDict>(
                "AttributeDict",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AttributeDict {
        static instance: ::protobuf::rt::LazyV2<AttributeDict> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AttributeDict::new)
    }
}

impl ::protobuf::Clear for AttributeDict {
    fn clear(&mut self) {
        self.pair.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeDict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeDict {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlindedCertificateSecret {
    // message fields
    pub blinded_certificate_secrets: ::std::string::String,
    pub blinded_certificate_secrets_correctness_proof: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlindedCertificateSecret {
    fn default() -> &'a BlindedCertificateSecret {
        <BlindedCertificateSecret as ::protobuf::Message>::default_instance()
    }
}

impl BlindedCertificateSecret {
    pub fn new() -> BlindedCertificateSecret {
        ::std::default::Default::default()
    }

    // string blinded_certificate_secrets = 1;


    pub fn get_blinded_certificate_secrets(&self) -> &str {
        &self.blinded_certificate_secrets
    }
    pub fn clear_blinded_certificate_secrets(&mut self) {
        self.blinded_certificate_secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinded_certificate_secrets(&mut self, v: ::std::string::String) {
        self.blinded_certificate_secrets = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinded_certificate_secrets(&mut self) -> &mut ::std::string::String {
        &mut self.blinded_certificate_secrets
    }

    // Take field
    pub fn take_blinded_certificate_secrets(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blinded_certificate_secrets, ::std::string::String::new())
    }

    // string blinded_certificate_secrets_correctness_proof = 2;


    pub fn get_blinded_certificate_secrets_correctness_proof(&self) -> &str {
        &self.blinded_certificate_secrets_correctness_proof
    }
    pub fn clear_blinded_certificate_secrets_correctness_proof(&mut self) {
        self.blinded_certificate_secrets_correctness_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinded_certificate_secrets_correctness_proof(&mut self, v: ::std::string::String) {
        self.blinded_certificate_secrets_correctness_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinded_certificate_secrets_correctness_proof(&mut self) -> &mut ::std::string::String {
        &mut self.blinded_certificate_secrets_correctness_proof
    }

    // Take field
    pub fn take_blinded_certificate_secrets_correctness_proof(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blinded_certificate_secrets_correctness_proof, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BlindedCertificateSecret {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.blinded_certificate_secrets)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.blinded_certificate_secrets_correctness_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blinded_certificate_secrets.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.blinded_certificate_secrets);
        }
        if !self.blinded_certificate_secrets_correctness_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.blinded_certificate_secrets_correctness_proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.blinded_certificate_secrets.is_empty() {
            os.write_string(1, &self.blinded_certificate_secrets)?;
        }
        if !self.blinded_certificate_secrets_correctness_proof.is_empty() {
            os.write_string(2, &self.blinded_certificate_secrets_correctness_proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlindedCertificateSecret {
        BlindedCertificateSecret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blinded_certificate_secrets",
                |m: &BlindedCertificateSecret| { &m.blinded_certificate_secrets },
                |m: &mut BlindedCertificateSecret| { &mut m.blinded_certificate_secrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blinded_certificate_secrets_correctness_proof",
                |m: &BlindedCertificateSecret| { &m.blinded_certificate_secrets_correctness_proof },
                |m: &mut BlindedCertificateSecret| { &mut m.blinded_certificate_secrets_correctness_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlindedCertificateSecret>(
                "BlindedCertificateSecret",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlindedCertificateSecret {
        static instance: ::protobuf::rt::LazyV2<BlindedCertificateSecret> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlindedCertificateSecret::new)
    }
}

impl ::protobuf::Clear for BlindedCertificateSecret {
    fn clear(&mut self) {
        self.blinded_certificate_secrets.clear();
        self.blinded_certificate_secrets_correctness_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlindedCertificateSecret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlindedCertificateSecret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CertificateSignature {
    // message fields
    pub certificate_signature: ::std::string::String,
    pub signature_correctness_proof: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CertificateSignature {
    fn default() -> &'a CertificateSignature {
        <CertificateSignature as ::protobuf::Message>::default_instance()
    }
}

impl CertificateSignature {
    pub fn new() -> CertificateSignature {
        ::std::default::Default::default()
    }

    // string certificate_signature = 1;


    pub fn get_certificate_signature(&self) -> &str {
        &self.certificate_signature
    }
    pub fn clear_certificate_signature(&mut self) {
        self.certificate_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_certificate_signature(&mut self, v: ::std::string::String) {
        self.certificate_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certificate_signature(&mut self) -> &mut ::std::string::String {
        &mut self.certificate_signature
    }

    // Take field
    pub fn take_certificate_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.certificate_signature, ::std::string::String::new())
    }

    // string signature_correctness_proof = 2;


    pub fn get_signature_correctness_proof(&self) -> &str {
        &self.signature_correctness_proof
    }
    pub fn clear_signature_correctness_proof(&mut self) {
        self.signature_correctness_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature_correctness_proof(&mut self, v: ::std::string::String) {
        self.signature_correctness_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature_correctness_proof(&mut self) -> &mut ::std::string::String {
        &mut self.signature_correctness_proof
    }

    // Take field
    pub fn take_signature_correctness_proof(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature_correctness_proof, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CertificateSignature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.certificate_signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature_correctness_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.certificate_signature.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.certificate_signature);
        }
        if !self.signature_correctness_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.signature_correctness_proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.certificate_signature.is_empty() {
            os.write_string(1, &self.certificate_signature)?;
        }
        if !self.signature_correctness_proof.is_empty() {
            os.write_string(2, &self.signature_correctness_proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CertificateSignature {
        CertificateSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificate_signature",
                |m: &CertificateSignature| { &m.certificate_signature },
                |m: &mut CertificateSignature| { &mut m.certificate_signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature_correctness_proof",
                |m: &CertificateSignature| { &m.signature_correctness_proof },
                |m: &mut CertificateSignature| { &mut m.signature_correctness_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CertificateSignature>(
                "CertificateSignature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CertificateSignature {
        static instance: ::protobuf::rt::LazyV2<CertificateSignature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CertificateSignature::new)
    }
}

impl ::protobuf::Clear for CertificateSignature {
    fn clear(&mut self) {
        self.certificate_signature.clear();
        self.signature_correctness_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CertificateSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CertificateSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Predicate {
    // message fields
    pub attribute_name: ::std::string::String,
    pub predicate_type: ::std::string::String,
    pub predicate_value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Predicate {
    fn default() -> &'a Predicate {
        <Predicate as ::protobuf::Message>::default_instance()
    }
}

impl Predicate {
    pub fn new() -> Predicate {
        ::std::default::Default::default()
    }

    // string attribute_name = 1;


    pub fn get_attribute_name(&self) -> &str {
        &self.attribute_name
    }
    pub fn clear_attribute_name(&mut self) {
        self.attribute_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_name(&mut self, v: ::std::string::String) {
        self.attribute_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute_name(&mut self) -> &mut ::std::string::String {
        &mut self.attribute_name
    }

    // Take field
    pub fn take_attribute_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attribute_name, ::std::string::String::new())
    }

    // string predicate_type = 2;


    pub fn get_predicate_type(&self) -> &str {
        &self.predicate_type
    }
    pub fn clear_predicate_type(&mut self) {
        self.predicate_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_predicate_type(&mut self, v: ::std::string::String) {
        self.predicate_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predicate_type(&mut self) -> &mut ::std::string::String {
        &mut self.predicate_type
    }

    // Take field
    pub fn take_predicate_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.predicate_type, ::std::string::String::new())
    }

    // uint64 predicate_value = 3;


    pub fn get_predicate_value(&self) -> u64 {
        self.predicate_value
    }
    pub fn clear_predicate_value(&mut self) {
        self.predicate_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_predicate_value(&mut self, v: u64) {
        self.predicate_value = v;
    }
}

impl ::protobuf::Message for Predicate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attribute_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.predicate_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.predicate_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.attribute_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.attribute_name);
        }
        if !self.predicate_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.predicate_type);
        }
        if self.predicate_value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.predicate_value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.attribute_name.is_empty() {
            os.write_string(1, &self.attribute_name)?;
        }
        if !self.predicate_type.is_empty() {
            os.write_string(2, &self.predicate_type)?;
        }
        if self.predicate_value != 0 {
            os.write_uint64(3, self.predicate_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Predicate {
        Predicate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attribute_name",
                |m: &Predicate| { &m.attribute_name },
                |m: &mut Predicate| { &mut m.attribute_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "predicate_type",
                |m: &Predicate| { &m.predicate_type },
                |m: &mut Predicate| { &mut m.predicate_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "predicate_value",
                |m: &Predicate| { &m.predicate_value },
                |m: &mut Predicate| { &mut m.predicate_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Predicate>(
                "Predicate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Predicate {
        static instance: ::protobuf::rt::LazyV2<Predicate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Predicate::new)
    }
}

impl ::protobuf::Clear for Predicate {
    fn clear(&mut self) {
        self.attribute_name.clear();
        self.predicate_type.clear();
        self.predicate_value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Predicate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Predicate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerificationRuleSet {
    // message fields
    pub revealed_attribute_name: ::protobuf::RepeatedField<::std::string::String>,
    pub attribute_predicate: ::protobuf::RepeatedField<Predicate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerificationRuleSet {
    fn default() -> &'a VerificationRuleSet {
        <VerificationRuleSet as ::protobuf::Message>::default_instance()
    }
}

impl VerificationRuleSet {
    pub fn new() -> VerificationRuleSet {
        ::std::default::Default::default()
    }

    // repeated string revealed_attribute_name = 1;


    pub fn get_revealed_attribute_name(&self) -> &[::std::string::String] {
        &self.revealed_attribute_name
    }
    pub fn clear_revealed_attribute_name(&mut self) {
        self.revealed_attribute_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_revealed_attribute_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.revealed_attribute_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_revealed_attribute_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.revealed_attribute_name
    }

    // Take field
    pub fn take_revealed_attribute_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.revealed_attribute_name, ::protobuf::RepeatedField::new())
    }

    // repeated .com.webank.wedpr.scd.proto.Predicate attribute_predicate = 2;


    pub fn get_attribute_predicate(&self) -> &[Predicate] {
        &self.attribute_predicate
    }
    pub fn clear_attribute_predicate(&mut self) {
        self.attribute_predicate.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_predicate(&mut self, v: ::protobuf::RepeatedField<Predicate>) {
        self.attribute_predicate = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_predicate(&mut self) -> &mut ::protobuf::RepeatedField<Predicate> {
        &mut self.attribute_predicate
    }

    // Take field
    pub fn take_attribute_predicate(&mut self) -> ::protobuf::RepeatedField<Predicate> {
        ::std::mem::replace(&mut self.attribute_predicate, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VerificationRuleSet {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute_predicate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.revealed_attribute_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attribute_predicate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.revealed_attribute_name {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.attribute_predicate {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.revealed_attribute_name {
            os.write_string(1, &v)?;
        };
        for v in &self.attribute_predicate {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerificationRuleSet {
        VerificationRuleSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "revealed_attribute_name",
                |m: &VerificationRuleSet| { &m.revealed_attribute_name },
                |m: &mut VerificationRuleSet| { &mut m.revealed_attribute_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Predicate>>(
                "attribute_predicate",
                |m: &VerificationRuleSet| { &m.attribute_predicate },
                |m: &mut VerificationRuleSet| { &mut m.attribute_predicate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerificationRuleSet>(
                "VerificationRuleSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerificationRuleSet {
        static instance: ::protobuf::rt::LazyV2<VerificationRuleSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerificationRuleSet::new)
    }
}

impl ::protobuf::Clear for VerificationRuleSet {
    fn clear(&mut self) {
        self.revealed_attribute_name.clear();
        self.attribute_predicate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerificationRuleSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationRuleSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignCertificateRequest {
    // message fields
    pub certificate_attribute_dict: ::protobuf::SingularPtrField<AttributeDict>,
    pub blinded_certificate_secrets: ::std::string::String,
    pub blinded_certificate_secrets_correctness_proof: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignCertificateRequest {
    fn default() -> &'a SignCertificateRequest {
        <SignCertificateRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignCertificateRequest {
    pub fn new() -> SignCertificateRequest {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.scd.proto.AttributeDict certificate_attribute_dict = 1;


    pub fn get_certificate_attribute_dict(&self) -> &AttributeDict {
        self.certificate_attribute_dict.as_ref().unwrap_or_else(|| <AttributeDict as ::protobuf::Message>::default_instance())
    }
    pub fn clear_certificate_attribute_dict(&mut self) {
        self.certificate_attribute_dict.clear();
    }

    pub fn has_certificate_attribute_dict(&self) -> bool {
        self.certificate_attribute_dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certificate_attribute_dict(&mut self, v: AttributeDict) {
        self.certificate_attribute_dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certificate_attribute_dict(&mut self) -> &mut AttributeDict {
        if self.certificate_attribute_dict.is_none() {
            self.certificate_attribute_dict.set_default();
        }
        self.certificate_attribute_dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_certificate_attribute_dict(&mut self) -> AttributeDict {
        self.certificate_attribute_dict.take().unwrap_or_else(|| AttributeDict::new())
    }

    // string blinded_certificate_secrets = 2;


    pub fn get_blinded_certificate_secrets(&self) -> &str {
        &self.blinded_certificate_secrets
    }
    pub fn clear_blinded_certificate_secrets(&mut self) {
        self.blinded_certificate_secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinded_certificate_secrets(&mut self, v: ::std::string::String) {
        self.blinded_certificate_secrets = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinded_certificate_secrets(&mut self) -> &mut ::std::string::String {
        &mut self.blinded_certificate_secrets
    }

    // Take field
    pub fn take_blinded_certificate_secrets(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blinded_certificate_secrets, ::std::string::String::new())
    }

    // string blinded_certificate_secrets_correctness_proof = 3;


    pub fn get_blinded_certificate_secrets_correctness_proof(&self) -> &str {
        &self.blinded_certificate_secrets_correctness_proof
    }
    pub fn clear_blinded_certificate_secrets_correctness_proof(&mut self) {
        self.blinded_certificate_secrets_correctness_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_blinded_certificate_secrets_correctness_proof(&mut self, v: ::std::string::String) {
        self.blinded_certificate_secrets_correctness_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blinded_certificate_secrets_correctness_proof(&mut self) -> &mut ::std::string::String {
        &mut self.blinded_certificate_secrets_correctness_proof
    }

    // Take field
    pub fn take_blinded_certificate_secrets_correctness_proof(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blinded_certificate_secrets_correctness_proof, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignCertificateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.certificate_attribute_dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.certificate_attribute_dict)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.blinded_certificate_secrets)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.blinded_certificate_secrets_correctness_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.certificate_attribute_dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.blinded_certificate_secrets.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.blinded_certificate_secrets);
        }
        if !self.blinded_certificate_secrets_correctness_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.blinded_certificate_secrets_correctness_proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.certificate_attribute_dict.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.blinded_certificate_secrets.is_empty() {
            os.write_string(2, &self.blinded_certificate_secrets)?;
        }
        if !self.blinded_certificate_secrets_correctness_proof.is_empty() {
            os.write_string(3, &self.blinded_certificate_secrets_correctness_proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignCertificateRequest {
        SignCertificateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttributeDict>>(
                "certificate_attribute_dict",
                |m: &SignCertificateRequest| { &m.certificate_attribute_dict },
                |m: &mut SignCertificateRequest| { &mut m.certificate_attribute_dict },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blinded_certificate_secrets",
                |m: &SignCertificateRequest| { &m.blinded_certificate_secrets },
                |m: &mut SignCertificateRequest| { &mut m.blinded_certificate_secrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blinded_certificate_secrets_correctness_proof",
                |m: &SignCertificateRequest| { &m.blinded_certificate_secrets_correctness_proof },
                |m: &mut SignCertificateRequest| { &mut m.blinded_certificate_secrets_correctness_proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignCertificateRequest>(
                "SignCertificateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignCertificateRequest {
        static instance: ::protobuf::rt::LazyV2<SignCertificateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignCertificateRequest::new)
    }
}

impl ::protobuf::Clear for SignCertificateRequest {
    fn clear(&mut self) {
        self.certificate_attribute_dict.clear();
        self.blinded_certificate_secrets.clear();
        self.blinded_certificate_secrets_correctness_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignCertificateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignCertificateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyRequest {
    // message fields
    pub certificate_template: ::protobuf::SingularPtrField<CertificateTemplate>,
    pub verification_proof: ::std::string::String,
    pub verification_nonce: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyRequest {
    fn default() -> &'a VerifyRequest {
        <VerifyRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerifyRequest {
    pub fn new() -> VerifyRequest {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.scd.proto.CertificateTemplate certificate_template = 1;


    pub fn get_certificate_template(&self) -> &CertificateTemplate {
        self.certificate_template.as_ref().unwrap_or_else(|| <CertificateTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_certificate_template(&mut self) {
        self.certificate_template.clear();
    }

    pub fn has_certificate_template(&self) -> bool {
        self.certificate_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certificate_template(&mut self, v: CertificateTemplate) {
        self.certificate_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certificate_template(&mut self) -> &mut CertificateTemplate {
        if self.certificate_template.is_none() {
            self.certificate_template.set_default();
        }
        self.certificate_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_certificate_template(&mut self) -> CertificateTemplate {
        self.certificate_template.take().unwrap_or_else(|| CertificateTemplate::new())
    }

    // string verification_proof = 2;


    pub fn get_verification_proof(&self) -> &str {
        &self.verification_proof
    }
    pub fn clear_verification_proof(&mut self) {
        self.verification_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_verification_proof(&mut self, v: ::std::string::String) {
        self.verification_proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verification_proof(&mut self) -> &mut ::std::string::String {
        &mut self.verification_proof
    }

    // Take field
    pub fn take_verification_proof(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.verification_proof, ::std::string::String::new())
    }

    // string verification_nonce = 3;


    pub fn get_verification_nonce(&self) -> &str {
        &self.verification_nonce
    }
    pub fn clear_verification_nonce(&mut self) {
        self.verification_nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_verification_nonce(&mut self, v: ::std::string::String) {
        self.verification_nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verification_nonce(&mut self) -> &mut ::std::string::String {
        &mut self.verification_nonce
    }

    // Take field
    pub fn take_verification_nonce(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.verification_nonce, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VerifyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.certificate_template {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.certificate_template)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.verification_proof)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.verification_nonce)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.certificate_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.verification_proof.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.verification_proof);
        }
        if !self.verification_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.verification_nonce);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.certificate_template.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.verification_proof.is_empty() {
            os.write_string(2, &self.verification_proof)?;
        }
        if !self.verification_nonce.is_empty() {
            os.write_string(3, &self.verification_nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyRequest {
        VerifyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CertificateTemplate>>(
                "certificate_template",
                |m: &VerifyRequest| { &m.certificate_template },
                |m: &mut VerifyRequest| { &mut m.certificate_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "verification_proof",
                |m: &VerifyRequest| { &m.verification_proof },
                |m: &mut VerifyRequest| { &mut m.verification_proof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "verification_nonce",
                |m: &VerifyRequest| { &m.verification_nonce },
                |m: &mut VerifyRequest| { &mut m.verification_nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyRequest>(
                "VerifyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyRequest {
        static instance: ::protobuf::rt::LazyV2<VerifyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyRequest::new)
    }
}

impl ::protobuf::Clear for VerifyRequest {
    fn clear(&mut self) {
        self.certificate_template.clear();
        self.verification_proof.clear();
        self.verification_nonce.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScdResult {
    // message fields
    pub certificate_template: ::protobuf::SingularPtrField<CertificateTemplate>,
    pub template_private_key: ::protobuf::SingularPtrField<TemplatePrivateKey>,
    pub issuer_nonce: ::std::string::String,
    pub certificate_signature: ::protobuf::SingularPtrField<CertificateSignature>,
    pub user_nonce: ::std::string::String,
    pub sign_certificate_request: ::protobuf::SingularPtrField<SignCertificateRequest>,
    pub user_private_key: ::std::string::String,
    pub certificate_secrets_blinding_factors: ::std::string::String,
    pub verification_nonce: ::std::string::String,
    pub verify_request: ::protobuf::SingularPtrField<VerifyRequest>,
    pub revealed_attribute_dict: ::protobuf::SingularPtrField<AttributeDict>,
    pub bool_result: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScdResult {
    fn default() -> &'a ScdResult {
        <ScdResult as ::protobuf::Message>::default_instance()
    }
}

impl ScdResult {
    pub fn new() -> ScdResult {
        ::std::default::Default::default()
    }

    // .com.webank.wedpr.scd.proto.CertificateTemplate certificate_template = 1;


    pub fn get_certificate_template(&self) -> &CertificateTemplate {
        self.certificate_template.as_ref().unwrap_or_else(|| <CertificateTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_certificate_template(&mut self) {
        self.certificate_template.clear();
    }

    pub fn has_certificate_template(&self) -> bool {
        self.certificate_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certificate_template(&mut self, v: CertificateTemplate) {
        self.certificate_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certificate_template(&mut self) -> &mut CertificateTemplate {
        if self.certificate_template.is_none() {
            self.certificate_template.set_default();
        }
        self.certificate_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_certificate_template(&mut self) -> CertificateTemplate {
        self.certificate_template.take().unwrap_or_else(|| CertificateTemplate::new())
    }

    // .com.webank.wedpr.scd.proto.TemplatePrivateKey template_private_key = 2;


    pub fn get_template_private_key(&self) -> &TemplatePrivateKey {
        self.template_private_key.as_ref().unwrap_or_else(|| <TemplatePrivateKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_template_private_key(&mut self) {
        self.template_private_key.clear();
    }

    pub fn has_template_private_key(&self) -> bool {
        self.template_private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_private_key(&mut self, v: TemplatePrivateKey) {
        self.template_private_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_private_key(&mut self) -> &mut TemplatePrivateKey {
        if self.template_private_key.is_none() {
            self.template_private_key.set_default();
        }
        self.template_private_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_private_key(&mut self) -> TemplatePrivateKey {
        self.template_private_key.take().unwrap_or_else(|| TemplatePrivateKey::new())
    }

    // string issuer_nonce = 3;


    pub fn get_issuer_nonce(&self) -> &str {
        &self.issuer_nonce
    }
    pub fn clear_issuer_nonce(&mut self) {
        self.issuer_nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuer_nonce(&mut self, v: ::std::string::String) {
        self.issuer_nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer_nonce(&mut self) -> &mut ::std::string::String {
        &mut self.issuer_nonce
    }

    // Take field
    pub fn take_issuer_nonce(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.issuer_nonce, ::std::string::String::new())
    }

    // .com.webank.wedpr.scd.proto.CertificateSignature certificate_signature = 4;


    pub fn get_certificate_signature(&self) -> &CertificateSignature {
        self.certificate_signature.as_ref().unwrap_or_else(|| <CertificateSignature as ::protobuf::Message>::default_instance())
    }
    pub fn clear_certificate_signature(&mut self) {
        self.certificate_signature.clear();
    }

    pub fn has_certificate_signature(&self) -> bool {
        self.certificate_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certificate_signature(&mut self, v: CertificateSignature) {
        self.certificate_signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certificate_signature(&mut self) -> &mut CertificateSignature {
        if self.certificate_signature.is_none() {
            self.certificate_signature.set_default();
        }
        self.certificate_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_certificate_signature(&mut self) -> CertificateSignature {
        self.certificate_signature.take().unwrap_or_else(|| CertificateSignature::new())
    }

    // string user_nonce = 5;


    pub fn get_user_nonce(&self) -> &str {
        &self.user_nonce
    }
    pub fn clear_user_nonce(&mut self) {
        self.user_nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_nonce(&mut self, v: ::std::string::String) {
        self.user_nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_nonce(&mut self) -> &mut ::std::string::String {
        &mut self.user_nonce
    }

    // Take field
    pub fn take_user_nonce(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_nonce, ::std::string::String::new())
    }

    // .com.webank.wedpr.scd.proto.SignCertificateRequest sign_certificate_request = 6;


    pub fn get_sign_certificate_request(&self) -> &SignCertificateRequest {
        self.sign_certificate_request.as_ref().unwrap_or_else(|| <SignCertificateRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sign_certificate_request(&mut self) {
        self.sign_certificate_request.clear();
    }

    pub fn has_sign_certificate_request(&self) -> bool {
        self.sign_certificate_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sign_certificate_request(&mut self, v: SignCertificateRequest) {
        self.sign_certificate_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign_certificate_request(&mut self) -> &mut SignCertificateRequest {
        if self.sign_certificate_request.is_none() {
            self.sign_certificate_request.set_default();
        }
        self.sign_certificate_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_sign_certificate_request(&mut self) -> SignCertificateRequest {
        self.sign_certificate_request.take().unwrap_or_else(|| SignCertificateRequest::new())
    }

    // string user_private_key = 7;


    pub fn get_user_private_key(&self) -> &str {
        &self.user_private_key
    }
    pub fn clear_user_private_key(&mut self) {
        self.user_private_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_private_key(&mut self, v: ::std::string::String) {
        self.user_private_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_private_key(&mut self) -> &mut ::std::string::String {
        &mut self.user_private_key
    }

    // Take field
    pub fn take_user_private_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_private_key, ::std::string::String::new())
    }

    // string certificate_secrets_blinding_factors = 8;


    pub fn get_certificate_secrets_blinding_factors(&self) -> &str {
        &self.certificate_secrets_blinding_factors
    }
    pub fn clear_certificate_secrets_blinding_factors(&mut self) {
        self.certificate_secrets_blinding_factors.clear();
    }

    // Param is passed by value, moved
    pub fn set_certificate_secrets_blinding_factors(&mut self, v: ::std::string::String) {
        self.certificate_secrets_blinding_factors = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certificate_secrets_blinding_factors(&mut self) -> &mut ::std::string::String {
        &mut self.certificate_secrets_blinding_factors
    }

    // Take field
    pub fn take_certificate_secrets_blinding_factors(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.certificate_secrets_blinding_factors, ::std::string::String::new())
    }

    // string verification_nonce = 9;


    pub fn get_verification_nonce(&self) -> &str {
        &self.verification_nonce
    }
    pub fn clear_verification_nonce(&mut self) {
        self.verification_nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_verification_nonce(&mut self, v: ::std::string::String) {
        self.verification_nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verification_nonce(&mut self) -> &mut ::std::string::String {
        &mut self.verification_nonce
    }

    // Take field
    pub fn take_verification_nonce(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.verification_nonce, ::std::string::String::new())
    }

    // .com.webank.wedpr.scd.proto.VerifyRequest verify_request = 10;


    pub fn get_verify_request(&self) -> &VerifyRequest {
        self.verify_request.as_ref().unwrap_or_else(|| <VerifyRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_verify_request(&mut self) {
        self.verify_request.clear();
    }

    pub fn has_verify_request(&self) -> bool {
        self.verify_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verify_request(&mut self, v: VerifyRequest) {
        self.verify_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verify_request(&mut self) -> &mut VerifyRequest {
        if self.verify_request.is_none() {
            self.verify_request.set_default();
        }
        self.verify_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_verify_request(&mut self) -> VerifyRequest {
        self.verify_request.take().unwrap_or_else(|| VerifyRequest::new())
    }

    // .com.webank.wedpr.scd.proto.AttributeDict revealed_attribute_dict = 11;


    pub fn get_revealed_attribute_dict(&self) -> &AttributeDict {
        self.revealed_attribute_dict.as_ref().unwrap_or_else(|| <AttributeDict as ::protobuf::Message>::default_instance())
    }
    pub fn clear_revealed_attribute_dict(&mut self) {
        self.revealed_attribute_dict.clear();
    }

    pub fn has_revealed_attribute_dict(&self) -> bool {
        self.revealed_attribute_dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revealed_attribute_dict(&mut self, v: AttributeDict) {
        self.revealed_attribute_dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revealed_attribute_dict(&mut self) -> &mut AttributeDict {
        if self.revealed_attribute_dict.is_none() {
            self.revealed_attribute_dict.set_default();
        }
        self.revealed_attribute_dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_revealed_attribute_dict(&mut self) -> AttributeDict {
        self.revealed_attribute_dict.take().unwrap_or_else(|| AttributeDict::new())
    }

    // bool bool_result = 12;


    pub fn get_bool_result(&self) -> bool {
        self.bool_result
    }
    pub fn clear_bool_result(&mut self) {
        self.bool_result = false;
    }

    // Param is passed by value, moved
    pub fn set_bool_result(&mut self, v: bool) {
        self.bool_result = v;
    }
}

impl ::protobuf::Message for ScdResult {
    fn is_initialized(&self) -> bool {
        for v in &self.certificate_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.template_private_key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.certificate_signature {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sign_certificate_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.verify_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.revealed_attribute_dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.certificate_template)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template_private_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.issuer_nonce)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.certificate_signature)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_nonce)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sign_certificate_request)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_private_key)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.certificate_secrets_blinding_factors)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.verification_nonce)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.verify_request)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.revealed_attribute_dict)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bool_result = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.certificate_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.template_private_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.issuer_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.issuer_nonce);
        }
        if let Some(ref v) = self.certificate_signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.user_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_nonce);
        }
        if let Some(ref v) = self.sign_certificate_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.user_private_key.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.user_private_key);
        }
        if !self.certificate_secrets_blinding_factors.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.certificate_secrets_blinding_factors);
        }
        if !self.verification_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.verification_nonce);
        }
        if let Some(ref v) = self.verify_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.revealed_attribute_dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.bool_result != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.certificate_template.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.template_private_key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.issuer_nonce.is_empty() {
            os.write_string(3, &self.issuer_nonce)?;
        }
        if let Some(ref v) = self.certificate_signature.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.user_nonce.is_empty() {
            os.write_string(5, &self.user_nonce)?;
        }
        if let Some(ref v) = self.sign_certificate_request.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.user_private_key.is_empty() {
            os.write_string(7, &self.user_private_key)?;
        }
        if !self.certificate_secrets_blinding_factors.is_empty() {
            os.write_string(8, &self.certificate_secrets_blinding_factors)?;
        }
        if !self.verification_nonce.is_empty() {
            os.write_string(9, &self.verification_nonce)?;
        }
        if let Some(ref v) = self.verify_request.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.revealed_attribute_dict.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.bool_result != false {
            os.write_bool(12, self.bool_result)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScdResult {
        ScdResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CertificateTemplate>>(
                "certificate_template",
                |m: &ScdResult| { &m.certificate_template },
                |m: &mut ScdResult| { &mut m.certificate_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TemplatePrivateKey>>(
                "template_private_key",
                |m: &ScdResult| { &m.template_private_key },
                |m: &mut ScdResult| { &mut m.template_private_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "issuer_nonce",
                |m: &ScdResult| { &m.issuer_nonce },
                |m: &mut ScdResult| { &mut m.issuer_nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CertificateSignature>>(
                "certificate_signature",
                |m: &ScdResult| { &m.certificate_signature },
                |m: &mut ScdResult| { &mut m.certificate_signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_nonce",
                |m: &ScdResult| { &m.user_nonce },
                |m: &mut ScdResult| { &mut m.user_nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignCertificateRequest>>(
                "sign_certificate_request",
                |m: &ScdResult| { &m.sign_certificate_request },
                |m: &mut ScdResult| { &mut m.sign_certificate_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_private_key",
                |m: &ScdResult| { &m.user_private_key },
                |m: &mut ScdResult| { &mut m.user_private_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificate_secrets_blinding_factors",
                |m: &ScdResult| { &m.certificate_secrets_blinding_factors },
                |m: &mut ScdResult| { &mut m.certificate_secrets_blinding_factors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "verification_nonce",
                |m: &ScdResult| { &m.verification_nonce },
                |m: &mut ScdResult| { &mut m.verification_nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VerifyRequest>>(
                "verify_request",
                |m: &ScdResult| { &m.verify_request },
                |m: &mut ScdResult| { &mut m.verify_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttributeDict>>(
                "revealed_attribute_dict",
                |m: &ScdResult| { &m.revealed_attribute_dict },
                |m: &mut ScdResult| { &mut m.revealed_attribute_dict },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bool_result",
                |m: &ScdResult| { &m.bool_result },
                |m: &mut ScdResult| { &mut m.bool_result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScdResult>(
                "ScdResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScdResult {
        static instance: ::protobuf::rt::LazyV2<ScdResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScdResult::new)
    }
}

impl ::protobuf::Clear for ScdResult {
    fn clear(&mut self) {
        self.certificate_template.clear();
        self.template_private_key.clear();
        self.issuer_nonce.clear();
        self.certificate_signature.clear();
        self.user_nonce.clear();
        self.sign_certificate_request.clear();
        self.user_private_key.clear();
        self.certificate_secrets_blinding_factors.clear();
        self.verification_nonce.clear();
        self.verify_request.clear();
        self.revealed_attribute_dict.clear();
        self.bool_result = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScdResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScdResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16solution/scd/scd.proto\x12\x1acom.webank.wedpr.scd.proto\":\n\x11C\
    ertificateSchema\x12%\n\x0eattribute_name\x18\x01\x20\x03(\tR\rattribute\
    Name\"<\n\x12StringToStringPair\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x90\x02\n\x13Certi\
    ficateTemplate\x12\\\n\x12certificate_schema\x18\x01\x20\x01(\x0b2-.com.\
    webank.wedpr.scd.proto.CertificateSchemaR\x11certificateSchema\x12<\n\
    \x1atemplate_correctness_proof\x18\x02\x20\x01(\tR\x18templateCorrectnes\
    sProof\x12]\n\x13template_public_key\x18\x03\x20\x01(\x0b2-.com.webank.w\
    edpr.scd.proto.TemplatePublicKeyR\x11templatePublicKey\"%\n\x11TemplateP\
    ublicKey\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\"&\n\x12TemplatePri\
    vateKey\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\"S\n\rAttributeDict\
    \x12B\n\x04pair\x18\x01\x20\x03(\x0b2..com.webank.wedpr.scd.proto.String\
    ToStringPairR\x04pair\"\xbc\x01\n\x18BlindedCertificateSecret\x12>\n\x1b\
    blinded_certificate_secrets\x18\x01\x20\x01(\tR\x19blindedCertificateSec\
    rets\x12`\n-blinded_certificate_secrets_correctness_proof\x18\x02\x20\
    \x01(\tR)blindedCertificateSecretsCorrectnessProof\"\x8b\x01\n\x14Certif\
    icateSignature\x123\n\x15certificate_signature\x18\x01\x20\x01(\tR\x14ce\
    rtificateSignature\x12>\n\x1bsignature_correctness_proof\x18\x02\x20\x01\
    (\tR\x19signatureCorrectnessProof\"\x82\x01\n\tPredicate\x12%\n\x0eattri\
    bute_name\x18\x01\x20\x01(\tR\rattributeName\x12%\n\x0epredicate_type\
    \x18\x02\x20\x01(\tR\rpredicateType\x12'\n\x0fpredicate_value\x18\x03\
    \x20\x01(\x04R\x0epredicateValue\"\xa5\x01\n\x13VerificationRuleSet\x126\
    \n\x17revealed_attribute_name\x18\x01\x20\x03(\tR\x15revealedAttributeNa\
    me\x12V\n\x13attribute_predicate\x18\x02\x20\x03(\x0b2%.com.webank.wedpr\
    .scd.proto.PredicateR\x12attributePredicate\"\xa3\x02\n\x16SignCertifica\
    teRequest\x12g\n\x1acertificate_attribute_dict\x18\x01\x20\x01(\x0b2).co\
    m.webank.wedpr.scd.proto.AttributeDictR\x18certificateAttributeDict\x12>\
    \n\x1bblinded_certificate_secrets\x18\x02\x20\x01(\tR\x19blindedCertific\
    ateSecrets\x12`\n-blinded_certificate_secrets_correctness_proof\x18\x03\
    \x20\x01(\tR)blindedCertificateSecretsCorrectnessProof\"\xd1\x01\n\rVeri\
    fyRequest\x12b\n\x14certificate_template\x18\x01\x20\x01(\x0b2/.com.weba\
    nk.wedpr.scd.proto.CertificateTemplateR\x13certificateTemplate\x12-\n\
    \x12verification_proof\x18\x02\x20\x01(\tR\x11verificationProof\x12-\n\
    \x12verification_nonce\x18\x03\x20\x01(\tR\x11verificationNonce\"\xe8\
    \x06\n\tScdResult\x12b\n\x14certificate_template\x18\x01\x20\x01(\x0b2/.\
    com.webank.wedpr.scd.proto.CertificateTemplateR\x13certificateTemplate\
    \x12`\n\x14template_private_key\x18\x02\x20\x01(\x0b2..com.webank.wedpr.\
    scd.proto.TemplatePrivateKeyR\x12templatePrivateKey\x12!\n\x0cissuer_non\
    ce\x18\x03\x20\x01(\tR\x0bissuerNonce\x12e\n\x15certificate_signature\
    \x18\x04\x20\x01(\x0b20.com.webank.wedpr.scd.proto.CertificateSignatureR\
    \x14certificateSignature\x12\x1d\n\nuser_nonce\x18\x05\x20\x01(\tR\tuser\
    Nonce\x12l\n\x18sign_certificate_request\x18\x06\x20\x01(\x0b22.com.weba\
    nk.wedpr.scd.proto.SignCertificateRequestR\x16signCertificateRequest\x12\
    (\n\x10user_private_key\x18\x07\x20\x01(\tR\x0euserPrivateKey\x12O\n$cer\
    tificate_secrets_blinding_factors\x18\x08\x20\x01(\tR!certificateSecrets\
    BlindingFactors\x12-\n\x12verification_nonce\x18\t\x20\x01(\tR\x11verifi\
    cationNonce\x12P\n\x0everify_request\x18\n\x20\x01(\x0b2).com.webank.wed\
    pr.scd.proto.VerifyRequestR\rverifyRequest\x12a\n\x17revealed_attribute_\
    dict\x18\x0b\x20\x01(\x0b2).com.webank.wedpr.scd.proto.AttributeDictR\
    \x15revealedAttributeDict\x12\x1f\n\x0bbool_result\x18\x0c\x20\x01(\x08R\
    \nboolResultB\x1e\n\x1acom.webank.wedpr.scd.protoP\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
